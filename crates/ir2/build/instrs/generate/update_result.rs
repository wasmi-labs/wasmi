use super::{DisplayFieldsPattern, DisplayIndent, Op};
use crate::instrs::{Context, DisplayOpName, Field, FieldName, FieldTy, OpClass, OpClassKind};
use core::{fmt, fmt::Display};

pub struct DisplayUpdateOpResult<'a> {
    ctx: &'a Context,
    indent: DisplayIndent,
}

impl<'a> DisplayUpdateOpResult<'a> {
    pub fn new(ctx: &'a Context, indent: DisplayIndent) -> Self {
        Self { ctx, indent }
    }
}

impl Display for DisplayUpdateOpResult<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let indent = self.indent;
        let display_impl = DisplayUpdateOpResultImpl::new(self.ctx.ops(), indent.inc_by(3));
        let display_impls = DisplayUpdateOpResultImpls::new(self.ctx.ops(), indent);
        let unary_op_impls =
            DisplayUpdateOpResultForUnaryOperators::new(&self.ctx.unary_ops, indent);
        let binary_commutative_op_impls = DisplayUpdateOpResultForBinaryCommutativeOperators::new(
            &self.ctx.binary_commutative_ops,
            indent,
        );
        let load_op_impls = DisplayUpdateOpResultForLoadOperators::new(&self.ctx.load_ops, indent);
        emit!(f, indent =>
            "// This file is automatically generated by the `build.rs` script."
            "//"
            "// Do _not_ edit this file directly but change `build.rs` script logic instead."
            ""
            "impl crate::UpdateOperatorResult for crate::Op {"
            "    type Output = Self;"
            "    fn update_operator_result(&self, new_result: crate::Stack) -> ::core::option::Option<Self::Output> {"
            "        match *self {"
                         display_impl
            "            //_ => ::core::option::Option::None,"
            "        }"
            "    }"
            "}"
            display_impls
            unary_op_impls
            binary_commutative_op_impls
            load_op_impls
        );
        Ok(())
    }
}

pub struct DisplayUpdateOpResultImpl<'a> {
    ops: &'a [Op],
    indent: DisplayIndent,
}

impl<'a> DisplayUpdateOpResultImpl<'a> {
    fn new(ops: &'a [Op], indent: DisplayIndent) -> Self {
        Self { ops, indent }
    }

    fn emit(&self, f: &mut fmt::Formatter, op: &Op) -> fmt::Result {
        // let Some(result_ty) = op.result_ty() else {
        //     return Ok(());
        // };
        let indent = self.indent;
        let name = op.name();
        let fields_pattern = DisplayFieldsPattern::new(op.fields());
        write!(
            f,
            "\
            {indent}Self::{name} {{ {fields_pattern} }} => \n\
            {indent}    <crate::op::{name} as crate::UpdateOperatorResult>::update_operator_result(\n\
            {indent}        &crate::op::{name} {{ {fields_pattern} }},\n\
            {indent}        new_result,\n\
            {indent}    ).map(<Self as ::core::convert::From<<crate::op::{name} as crate::UpdateOperatorResult>::Output>>::from),\n\
            "
        )
        // match result_ty {
        //     FieldTy::Reg => {
        //         write!(
        //             f,
        //             "\
        //             {indent}Self::{name} {{ {fields_pattern} }} => \n\
        //             {indent}    <crate::op::{name} as crate::UpdateOperatorResult>::update_operator_result(\n\
        //             {indent}        &crate::op::{name} {{ {fields_pattern} }},\n\
        //             {indent}        new_result,\n\
        //             {indent}    ).map(<Self as ::core::convert::From<<crate::op::{name} as crate::UpdateOperatorResult>::Output>>::from),\n\
        //             "
        //         )
        //     }
        //     FieldTy::Stack => {
        //         write!(
        //             f,
        //             "\
        //             {indent}Self::{name} {{ {fields_pattern} }} => \n\
        //             {indent}    <crate::op::{name} as crate::UpdateOperatorResult>::update_operator_result(\n\
        //             {indent}        &crate::op::{name} {{ {fields_pattern} }},\n\
        //             {indent}        new_result,\n\
        //             {indent}    ).map(<Self as ::core::convert::From<<crate::op::{name} as crate::UpdateOperatorResult>::Output>>::from),\n\
        //             "
        //         )
        //     }
        //     _ => unreachable!(),
        // }
    }
}

impl Display for DisplayUpdateOpResultImpl<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let Some((first, rest)) = self.ops.split_first() else {
            return Ok(());
        };
        self.emit(f, first)?;
        for op in rest {
            self.emit(f, op)?;
        }
        Ok(())
    }
}

pub struct DisplayUpdateOpResultImpls<'a> {
    ops: &'a [Op],
    indent: DisplayIndent,
}

impl<'a> DisplayUpdateOpResultImpls<'a> {
    fn new(ops: &'a [Op], indent: DisplayIndent) -> Self {
        Self { ops, indent }
    }

    fn emit(&self, f: &mut fmt::Formatter, op: &Op) -> fmt::Result {
        let indent = self.indent;
        let name = op.name();
        if matches!(
            op.kind(),
            OpClassKind::Select
                | OpClassKind::Binary
                | OpClassKind::TableGet
                | OpClassKind::MemoryGrow
        ) {
            write!(
                f,
                "\
                {indent}impl crate::UpdateOperatorResult for crate::op::{name} {{\n\
                {indent}    type Output = crate::NoOp;\n\
                {indent}}}\n\
                "
            )?;
            return Ok(());
        }
        let Some(result_ty) = op.result_ty() else {
            write!(
                f,
                "\
                {indent}impl crate::UpdateOperatorResult for crate::op::{name} {{\n\
                {indent}    type Output = crate::NoOp;\n\
                {indent}}}\n\
                "
            )?;
            return Ok(());
        };
        match result_ty {
            FieldTy::Reg
                if matches!(
                    op.kind(),
                    OpClassKind::GlobalGet | OpClassKind::TableSize | OpClassKind::MemorySize
                ) =>
            {
                let returned_op = match op.kind() {
                    OpClassKind::GlobalGet => "GlobalGet",
                    OpClassKind::MemorySize => "MemorySize",
                    OpClassKind::TableSize => "TableSize",
                    _ => unreachable!(),
                };
                write!(f, "\
                    {indent}impl crate::UpdateOperatorResult for crate::op::{name} {{\n\
                    {indent}    type Output = crate::op::{returned_op}_S;\n\
                    {indent}    fn update_operator_result(&self, new_result: crate::Stack) -> ::core::option::Option<Self::Output> {{\n\
                    {indent}        ::core::option::Option::Some(Self::Output {{\n\
                    {indent}            result: new_result,\n\
                    {indent}            index: self.index,\n\
                    {indent}        }})\n\
                    {indent}    }}\n\
                    {indent}}}\n\
                    {indent}\
                    "
                )?;
            }
            FieldTy::Stack => {
                let other_fields =
                    DisplayUpdateOpResultImplsFields::new(op.fields(), indent.inc_by(3));
                write!(f, "\
                    {indent}impl crate::UpdateOperatorResult for crate::op::{name} {{\n\
                    {indent}    type Output = Self;\n\
                    {indent}    fn update_operator_result(&self, new_result: crate::Stack) -> ::core::option::Option<Self::Output> {{\n\
                    {indent}        ::core::option::Option::Some(Self::Output {{\n\
                    {indent}            result: new_result,\n\
                                        {other_fields}\
                    {indent}        }})\n\
                    {indent}    }}\n\
                    {indent}}}\n\
                    {indent}\
                    "
                )?;
            }
            FieldTy::Reg => {
                // We handle these elsewhere.
                return Ok(());
            }
            _ => unreachable!(),
        }
        Ok(())
    }
}

impl Display for DisplayUpdateOpResultImpls<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let Some((first, rest)) = self.ops.split_first() else {
            return Ok(());
        };
        self.emit(f, first)?;
        for op in rest {
            self.emit(f, op)?;
        }
        Ok(())
    }
}

pub struct DisplayUpdateOpResultImplsFields<'a> {
    fields: &'a [Field],
    indent: DisplayIndent,
}

impl<'a> DisplayUpdateOpResultImplsFields<'a> {
    fn new(fields: &'a [Field], indent: DisplayIndent) -> Self {
        Self { fields, indent }
    }

    fn emit(&self, f: &mut fmt::Formatter, field: &Field) -> fmt::Result {
        let indent = self.indent;
        let name = field.name;
        if matches!(name, FieldName::Result) {
            // Handled elsewhere.
            return Ok(());
        }
        write!(f, "{indent}{name}: self.{name},\n")
    }
}

impl Display for DisplayUpdateOpResultImplsFields<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let Some((first, rest)) = self.fields.split_first() else {
            return Ok(());
        };
        self.emit(f, first)?;
        for field in rest {
            self.emit(f, field)?;
        }
        Ok(())
    }
}

pub struct DisplayUpdateOpResultForUnaryOperators<'a> {
    ops: &'a [OpClass],
    indent: DisplayIndent,
}

impl<'a> DisplayUpdateOpResultForUnaryOperators<'a> {
    pub fn new(ops: &'a [OpClass], indent: DisplayIndent) -> Self {
        Self { ops, indent }
    }

    fn emit(&self, f: &mut fmt::Formatter, op: &OpClass) -> fmt::Result {
        let indent = self.indent;
        let op_rr = op.op_rr();
        let op_rs = op.op_rs();
        let op_sr = op.op_sr();
        let op_ss = op.op_ss();
        let fields = &[FieldName::Input];
        write!(
            f,
            "{}\n{}",
            DisplayUpdateOpResultFor::new(op_rr, op_sr, fields, indent),
            DisplayUpdateOpResultFor::new(op_rs, op_ss, fields, indent),
        )?;
        Ok(())
    }
}

impl Display for DisplayUpdateOpResultForUnaryOperators<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let Some((first, rest)) = self.ops.split_first() else {
            return Ok(());
        };
        self.emit(f, first)?;
        for op in rest {
            writeln!(f)?;
            self.emit(f, op)?;
        }
        writeln!(f)?;
        Ok(())
    }
}

pub struct DisplayUpdateOpResultForBinaryCommutativeOperators<'a> {
    ops: &'a [OpClass],
    indent: DisplayIndent,
}

impl<'a> DisplayUpdateOpResultForBinaryCommutativeOperators<'a> {
    pub fn new(ops: &'a [OpClass], indent: DisplayIndent) -> Self {
        Self { ops, indent }
    }

    fn emit(&self, f: &mut fmt::Formatter, op: &OpClass) -> fmt::Result {
        let indent = self.indent;
        let ops = [
            (op.op_rri(), op.op_sri()),
            (op.op_rrs(), op.op_srs()),
            (op.op_rsi(), op.op_ssi()),
            (op.op_rss(), op.op_sss()),
        ];
        let fields = &[FieldName::Lhs, FieldName::Rhs];
        for (op_r, op_s) in ops {
            write!(
                f,
                "\n{}",
                DisplayUpdateOpResultFor::new(op_r, op_s, fields, indent)
            )?;
        }
        Ok(())
    }
}

impl Display for DisplayUpdateOpResultForBinaryCommutativeOperators<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let Some((first, rest)) = self.ops.split_first() else {
            return Ok(());
        };
        self.emit(f, first)?;
        for op in rest {
            writeln!(f)?;
            self.emit(f, op)?;
        }
        writeln!(f)?;
        Ok(())
    }
}

pub struct DisplayUpdateOpResultForLoadOperators<'a> {
    ops: &'a [OpClass],
    indent: DisplayIndent,
}

impl<'a> DisplayUpdateOpResultForLoadOperators<'a> {
    pub fn new(ops: &'a [OpClass], indent: DisplayIndent) -> Self {
        Self { ops, indent }
    }

    fn emit(&self, f: &mut fmt::Formatter, op: &OpClass) -> fmt::Result {
        let indent = self.indent;
        let mem0_ops = [
            (op.op_mem0_ri(), op.op_mem0_si(), &[FieldName::Address][..]),
            (
                op.op_mem0_rr(),
                op.op_mem0_sr(),
                &[FieldName::Ptr, FieldName::Offset][..],
            ),
            (
                op.op_mem0_rs(),
                op.op_mem0_ss(),
                &[FieldName::Ptr, FieldName::Offset][..],
            ),
        ];
        let ops = [op.op_ri(), op.op_rr(), op.op_rs()];
        for (op_r, op_s, fields) in mem0_ops {
            write!(
                f,
                "\n{}",
                DisplayUpdateOpResultFor::new(op_r, op_s, fields, indent)
            )?;
        }
        for op in ops {
            write!(f, "\n{}", DisplayUpdateOpResultAsNoOp::new(op, indent))?;
        }
        Ok(())
    }
}

impl Display for DisplayUpdateOpResultForLoadOperators<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let Some((first, rest)) = self.ops.split_first() else {
            return Ok(());
        };
        self.emit(f, first)?;
        for op in rest {
            writeln!(f)?;
            self.emit(f, op)?;
        }
        writeln!(f)?;
        Ok(())
    }
}

pub struct DisplayUpdateOpResultAsNoOp<'a> {
    self_ty: DisplayOpName<'a>,
    indent: DisplayIndent,
}

impl<'a> DisplayUpdateOpResultAsNoOp<'a> {
    pub fn new(self_ty: DisplayOpName<'a>, indent: DisplayIndent) -> Self {
        Self { self_ty, indent }
    }
}

impl Display for DisplayUpdateOpResultAsNoOp<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let indent = self.indent;
        let self_op = self.self_ty;
        write!(
            f,
            "\
            {indent}impl crate::UpdateOperatorResult for crate::op::{self_op} {{\n\
            {indent}    type Output = crate::NoOp;\n\
            {indent}}}\
            "
        )
    }
}

pub struct DisplayUpdateOpResultFor<'a> {
    self_ty: DisplayOpName<'a>,
    return_ty: DisplayOpName<'a>,
    fields: &'a [FieldName],
    indent: DisplayIndent,
}

impl<'a> DisplayUpdateOpResultFor<'a> {
    pub fn new(
        self_ty: DisplayOpName<'a>,
        return_ty: DisplayOpName<'a>,
        fields: &'a [FieldName],
        indent: DisplayIndent,
    ) -> Self {
        Self {
            self_ty,
            return_ty,
            fields,
            indent,
        }
    }
}

impl Display for DisplayUpdateOpResultFor<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let indent = self.indent;
        let self_op = self.self_ty;
        let return_op = self.return_ty;
        let assign_fields = DisplayFieldsSelfAssignment::new(self.fields, indent.inc_by(3));
        write!(
            f,
            "\
            {indent}impl crate::UpdateOperatorResult for crate::op::{self_op} {{\n\
            {indent}    type Output = crate::op::{return_op};\n\
            {indent}    fn update_operator_result(&self, new_result: crate::Stack) -> ::core::option::Option<Self::Output> {{\n\
            {indent}        ::core::option::Option::Some(Self::Output {{\n\
            {indent}            result: new_result,\n\
                                {assign_fields}\
            {indent}        }})\n\
            {indent}    }}\n\
            {indent}}}\
            "
        )
    }
}

pub struct DisplayFieldsSelfAssignment<'a> {
    fields: &'a [FieldName],
    indent: DisplayIndent,
}

impl<'a> DisplayFieldsSelfAssignment<'a> {
    pub fn new(fields: &'a [FieldName], indent: DisplayIndent) -> Self {
        Self { fields, indent }
    }

    fn emit(&self, f: &mut fmt::Formatter, name: &FieldName) -> fmt::Result {
        let indent = self.indent;
        write!(f, "{indent}{name}: self.{name},")
    }
}

impl Display for DisplayFieldsSelfAssignment<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let Some((first, rest)) = self.fields.split_first() else {
            return Ok(());
        };
        self.emit(f, first)?;
        for op in rest {
            writeln!(f)?;
            self.emit(f, op)?;
        }
        writeln!(f)?;
        Ok(())
    }
}
