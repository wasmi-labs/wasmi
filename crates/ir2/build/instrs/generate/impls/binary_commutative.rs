use super::super::{DisplayIndent, ImmediateTy};
use crate::instrs::OpClass;
use core::{fmt, fmt::Display};

pub struct DisplayBinaryCommutativeOperatorImpls<'a> {
    ops: &'a [OpClass],
    indent: DisplayIndent,
}

impl<'a> DisplayBinaryCommutativeOperatorImpls<'a> {
    pub fn new(ops: &'a [OpClass], indent: DisplayIndent) -> Self {
        Self { ops, indent }
    }

    fn emit(&self, f: &mut fmt::Formatter, op: &OpClass) -> fmt::Result {
        let indent = self.indent;
        let name = &*op.name;
        let op_rri = op.op_rri();
        let op_rrs = op.op_rrs();
        let op_rsi = op.op_rsi();
        let op_rss = op.op_rss();
        let op_sri = op.op_sri();
        let op_srs = op.op_srs();
        let op_ssi = op.op_ssi();
        let op_sss = op.op_sss();
        let imm = ImmediateTy::from(op.ty);
        write!(
            f,
            "\
            {indent}pub enum {name} {{}}\n\
            {indent}impl crate::BinaryCommutativeOperator for {name} {{\n\
            {indent}    const NAME: &'static ::core::primitive::str = \"{name}\";\n\
            {indent}    type Imm = {imm};\n\
            {indent}    type OpRri = crate::op::{op_rri};\n\
            {indent}    type OpRrs = crate::op::{op_rrs};\n\
            {indent}    type OpRsi = crate::op::{op_rsi};\n\
            {indent}    type OpRss = crate::op::{op_rss};\n\
            {indent}    type OpSri = crate::op::{op_sri};\n\
            {indent}    type OpSrs = crate::op::{op_srs};\n\
            {indent}    type OpSsi = crate::op::{op_ssi};\n\
            {indent}    type OpSss = crate::op::{op_sss};\n\
            {indent}    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {{\n\
            {indent}        Self::OpRri {{ result, lhs, rhs }}\n\
            {indent}    }}\n\
            {indent}    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {{\n\
            {indent}        Self::OpRrs {{ result, lhs, rhs }}\n\
            {indent}    }}\n\
            {indent}    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {{\n\
            {indent}        Self::OpRsi {{ result, lhs, rhs }}\n\
            {indent}    }}\n\
            {indent}    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {{\n\
            {indent}        Self::OpRss {{ result, lhs, rhs }}\n\
            {indent}    }}\n\
            {indent}    fn make_sri(result: crate::Stack, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpSri {{\n\
            {indent}        Self::OpSri {{ result, lhs, rhs }}\n\
            {indent}    }}\n\
            {indent}    fn make_srs(result: crate::Stack, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpSrs {{\n\
            {indent}        Self::OpSrs {{ result, lhs, rhs }}\n\
            {indent}    }}\n\
            {indent}    fn make_ssi(result: crate::Stack, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpSsi {{\n\
            {indent}        Self::OpSsi {{ result, lhs, rhs }}\n\
            {indent}    }}\n\
            {indent}    fn make_sss(result: crate::Stack, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpSss {{\n\
            {indent}        Self::OpSss {{ result, lhs, rhs }}\n\
            {indent}    }}\n\
            {indent}}}\
            "
        )
    }
}

impl Display for DisplayBinaryCommutativeOperatorImpls<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        emit!(f, self.indent =>
            "// This file is automatically generated by the `build.rs` script."
            "//"
            "// Do _not_ edit this file directly but change `build.rs` script logic instead."
            ""
        );
        let Some((first, rest)) = self.ops.split_first() else {
            return Ok(());
        };
        self.emit(f, first)?;
        for op in rest {
            writeln!(f)?;
            self.emit(f, op)?;
        }
        writeln!(f)?;
        Ok(())
    }
}
