use super::super::{DisplayIndent, Operand};
use crate::instrs::LoadOp;
use core::{fmt, fmt::Display};

pub struct DisplayLoadOperatorImpls<'a> {
    ops: &'a [LoadOp],
    indent: DisplayIndent,
}

impl<'a> DisplayLoadOperatorImpls<'a> {
    pub fn new(ops: &'a [LoadOp], indent: DisplayIndent) -> Self {
        Self { ops, indent }
    }

    fn emit(&self, f: &mut fmt::Formatter, op: &LoadOp) -> fmt::Result {
        let indent = self.indent;
        let name = &*op.name;
        let r_id = Operand::Reg.id();
        let s_id = Operand::Stack.id();
        let i_id = Operand::Immediate.id();
        let op_mem0_ri = format!("{name}Mem0_{r_id}{i_id}");
        let op_mem0_rr = format!("{name}Mem0_{r_id}{r_id}");
        let op_mem0_rs = format!("{name}Mem0_{r_id}{s_id}");
        let op_mem0_si = format!("{name}Mem0_{s_id}{i_id}");
        let op_mem0_sr = format!("{name}Mem0_{s_id}{r_id}");
        let op_mem0_ss = format!("{name}Mem0_{s_id}{s_id}");
        let op_ri = format!("{name}_{r_id}{i_id}");
        let op_rr = format!("{name}_{r_id}{r_id}");
        let op_rs = format!("{name}_{r_id}{s_id}");
        write!(
            f,
            "\
            {indent}pub enum {name} {{}}\n\
            {indent}impl crate::LoadOperator for {name} {{\n\
            {indent}    const NAME: &'static ::core::primitive::str = \"{name}\";\n\
            {indent}    type OpMem0Ri = crate::op::{op_mem0_ri};\n\
            {indent}    type OpMem0Rr = crate::op::{op_mem0_rr};\n\
            {indent}    type OpMem0Rs = crate::op::{op_mem0_rs};\n\
            {indent}    type OpMem0Si = crate::op::{op_mem0_si};\n\
            {indent}    type OpMem0Sr = crate::op::{op_mem0_sr};\n\
            {indent}    type OpMem0Ss = crate::op::{op_mem0_ss};\n\
            {indent}    type OpRi = crate::op::{op_ri};\n\
            {indent}    type OpRr = crate::op::{op_rr};\n\
            {indent}    type OpRs = crate::op::{op_rs};\n\
            {indent}    fn make_mem0_ri(result: crate::Reg, address: crate::Address) -> Self::OpMem0Ri {{\n\
            {indent}        Self::OpMem0Ri {{ result, address }}\n\
            {indent}    }}\n\
            {indent}    fn make_mem0_rr(result: crate::Reg, ptr: crate::Reg, offset: crate::Offset) -> Self::OpMem0Rr {{\n\
            {indent}        Self::OpMem0Rr {{ result, ptr, offset }}\n\
            {indent}    }}\n\
            {indent}    fn make_mem0_rs(result: crate::Reg, ptr: crate::Stack, offset: crate::Offset) -> Self::OpMem0Rs {{\n\
            {indent}        Self::OpMem0Rs {{ result, ptr, offset }}\n\
            {indent}    }}\n\
            {indent}    fn make_mem0_si(result: crate::Stack, address: crate::Address) -> Self::OpMem0Si {{\n\
            {indent}        Self::OpMem0Si {{ result, address }}\n\
            {indent}    }}\n\
            {indent}    fn make_mem0_sr(result: crate::Stack, ptr: crate::Reg, offset: crate::Offset) -> Self::OpMem0Sr {{\n\
            {indent}        Self::OpMem0Sr {{ result, ptr, offset }}\n\
            {indent}    }}\n\
            {indent}    fn make_mem0_ss(result: crate::Stack, ptr: crate::Stack, offset: crate::Offset) -> Self::OpMem0Ss {{\n\
            {indent}        Self::OpMem0Ss {{ result, ptr, offset }}\n\
            {indent}    }}\n\
            {indent}    fn make_ri(result: crate::Reg, address: crate::Address, memory: crate::Memory) -> Self::OpRi {{\n\
            {indent}        Self::OpRi {{ result, address, memory }}\n\
            {indent}    }}\n\
            {indent}    fn make_rr(result: crate::Reg, ptr: crate::Reg, offset: crate::Offset, memory: crate::Memory) -> Self::OpRr {{\n\
            {indent}        Self::OpRr {{ result, ptr, memory, offset }}\n\
            {indent}    }}\n\
            {indent}    fn make_rs(result: crate::Reg, ptr: crate::Stack, offset: crate::Offset, memory: crate::Memory) -> Self::OpRs {{\n\
            {indent}        Self::OpRs {{ result, ptr, memory, offset }}\n\
            {indent}    }}\n\
            {indent}}}\
            "
        )
    }
}

impl Display for DisplayLoadOperatorImpls<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        emit!(f, self.indent =>
            "// This file is automatically generated by the `build.rs` script."
            "//"
            "// Do _not_ edit this file directly but change `build.rs` script logic instead."
            ""
        );
        let Some((first, rest)) = self.ops.split_first() else {
            return Ok(());
        };
        self.emit(f, first)?;
        for op in rest {
            writeln!(f)?;
            self.emit(f, op)?;
        }
        writeln!(f)?;
        Ok(())
    }
}
