// This file is automatically generated by the `build.rs` script.
//
// Do _not_ edit this file directly but change `build.rs` script logic instead.

#![expect(unused_variables)]

pub enum I32Store {}
impl crate::StoreOperator for I32Store {
    const NAME: &'static ::core::primitive::str = "I32Store";
    type Imm = ::core::primitive::i32;
    type OpMem0Rr = crate::utils::NoOp;
    type OpMem0Ri = crate::op::I32StoreMem0_RI;
    type OpMem0Rs = crate::op::I32StoreMem0_RS;
    type OpMem0Sr = crate::op::I32StoreMem0_SR;
    type OpMem0Si = crate::op::I32StoreMem0_SI;
    type OpMem0Ss = crate::op::I32StoreMem0_SS;
    type OpMem0Ir = crate::op::I32StoreMem0_IR;
    type OpMem0Ii = crate::op::I32StoreMem0_II;
    type OpMem0Is = crate::op::I32StoreMem0_IS;
    type OpSs = crate::op::I32Store_SS;
    type OpSi = crate::op::I32Store_SI;
    type OpIs = crate::op::I32Store_IS;
    type OpIi = crate::op::I32Store_II;
    fn make_mem0_rr(ptr: crate::Reg, offset: crate::Offset, value: crate::Reg) -> ::core::option::Option<Self::OpMem0Rr> {
        ::core::option::Option::None
    }
    fn make_mem0_rs(ptr: crate::Reg, offset: crate::Offset, value: crate::Stack) -> Self::OpMem0Rs {
        Self::OpMem0Rs { ptr, offset, value }
    }
    fn make_mem0_ri(ptr: crate::Reg, offset: crate::Offset, value: Self::Imm) -> Self::OpMem0Ri {
        Self::OpMem0Ri { ptr, offset, value }
    }
    fn make_mem0_sr(ptr: crate::Stack, offset: crate::Offset, value: crate::Reg) -> Self::OpMem0Sr {
        Self::OpMem0Sr { ptr, offset, value }
    }
    fn make_mem0_ss(ptr: crate::Stack, offset: crate::Offset, value: crate::Stack) -> Self::OpMem0Ss {
        Self::OpMem0Ss { ptr, offset, value }
    }
    fn make_mem0_si(ptr: crate::Stack, offset: crate::Offset, value: Self::Imm) -> Self::OpMem0Si {
        Self::OpMem0Si { ptr, offset, value }
    }
    fn make_mem0_ir(address: crate::Address, value: crate::Reg) -> Self::OpMem0Ir {
        Self::OpMem0Ir { address, value }
    }
    fn make_mem0_is(address: crate::Address, value: crate::Stack) -> Self::OpMem0Is {
        Self::OpMem0Is { address, value }
    }
    fn make_mem0_ii(address: crate::Address, value: Self::Imm) -> Self::OpMem0Ii {
        Self::OpMem0Ii { address, value }
    }
    fn make_ss(ptr: crate::Stack, offset: crate::Offset, value: crate::Stack, memory: crate::Memory) -> Self::OpSs {
        Self::OpSs { ptr, value, offset, memory }
    }
    fn make_si(ptr: crate::Stack, offset: crate::Offset, value: Self::Imm, memory: crate::Memory) -> Self::OpSi {
        Self::OpSi { ptr, value, offset, memory }
    }
    fn make_is(address: crate::Address, value: crate::Stack, memory: crate::Memory) -> Self::OpIs {
        Self::OpIs { address, value, memory }
    }
    fn make_ii(address: crate::Address, value: Self::Imm, memory: crate::Memory) -> Self::OpIi {
        Self::OpIi { address, value, memory }
    }
}
pub enum I64Store {}
impl crate::StoreOperator for I64Store {
    const NAME: &'static ::core::primitive::str = "I64Store";
    type Imm = ::core::primitive::i64;
    type OpMem0Rr = crate::utils::NoOp;
    type OpMem0Ri = crate::op::I64StoreMem0_RI;
    type OpMem0Rs = crate::op::I64StoreMem0_RS;
    type OpMem0Sr = crate::op::I64StoreMem0_SR;
    type OpMem0Si = crate::op::I64StoreMem0_SI;
    type OpMem0Ss = crate::op::I64StoreMem0_SS;
    type OpMem0Ir = crate::op::I64StoreMem0_IR;
    type OpMem0Ii = crate::op::I64StoreMem0_II;
    type OpMem0Is = crate::op::I64StoreMem0_IS;
    type OpSs = crate::op::I64Store_SS;
    type OpSi = crate::op::I64Store_SI;
    type OpIs = crate::op::I64Store_IS;
    type OpIi = crate::op::I64Store_II;
    fn make_mem0_rr(ptr: crate::Reg, offset: crate::Offset, value: crate::Reg) -> ::core::option::Option<Self::OpMem0Rr> {
        ::core::option::Option::None
    }
    fn make_mem0_rs(ptr: crate::Reg, offset: crate::Offset, value: crate::Stack) -> Self::OpMem0Rs {
        Self::OpMem0Rs { ptr, offset, value }
    }
    fn make_mem0_ri(ptr: crate::Reg, offset: crate::Offset, value: Self::Imm) -> Self::OpMem0Ri {
        Self::OpMem0Ri { ptr, offset, value }
    }
    fn make_mem0_sr(ptr: crate::Stack, offset: crate::Offset, value: crate::Reg) -> Self::OpMem0Sr {
        Self::OpMem0Sr { ptr, offset, value }
    }
    fn make_mem0_ss(ptr: crate::Stack, offset: crate::Offset, value: crate::Stack) -> Self::OpMem0Ss {
        Self::OpMem0Ss { ptr, offset, value }
    }
    fn make_mem0_si(ptr: crate::Stack, offset: crate::Offset, value: Self::Imm) -> Self::OpMem0Si {
        Self::OpMem0Si { ptr, offset, value }
    }
    fn make_mem0_ir(address: crate::Address, value: crate::Reg) -> Self::OpMem0Ir {
        Self::OpMem0Ir { address, value }
    }
    fn make_mem0_is(address: crate::Address, value: crate::Stack) -> Self::OpMem0Is {
        Self::OpMem0Is { address, value }
    }
    fn make_mem0_ii(address: crate::Address, value: Self::Imm) -> Self::OpMem0Ii {
        Self::OpMem0Ii { address, value }
    }
    fn make_ss(ptr: crate::Stack, offset: crate::Offset, value: crate::Stack, memory: crate::Memory) -> Self::OpSs {
        Self::OpSs { ptr, value, offset, memory }
    }
    fn make_si(ptr: crate::Stack, offset: crate::Offset, value: Self::Imm, memory: crate::Memory) -> Self::OpSi {
        Self::OpSi { ptr, value, offset, memory }
    }
    fn make_is(address: crate::Address, value: crate::Stack, memory: crate::Memory) -> Self::OpIs {
        Self::OpIs { address, value, memory }
    }
    fn make_ii(address: crate::Address, value: Self::Imm, memory: crate::Memory) -> Self::OpIi {
        Self::OpIi { address, value, memory }
    }
}
pub enum F32Store {}
impl crate::StoreOperator for F32Store {
    const NAME: &'static ::core::primitive::str = "F32Store";
    type Imm = ::core::primitive::f32;
    type OpMem0Rr = crate::op::F32StoreMem0_RR;
    type OpMem0Ri = crate::op::F32StoreMem0_RI;
    type OpMem0Rs = crate::op::F32StoreMem0_RS;
    type OpMem0Sr = crate::op::F32StoreMem0_SR;
    type OpMem0Si = crate::op::F32StoreMem0_SI;
    type OpMem0Ss = crate::op::F32StoreMem0_SS;
    type OpMem0Ir = crate::op::F32StoreMem0_IR;
    type OpMem0Ii = crate::op::F32StoreMem0_II;
    type OpMem0Is = crate::op::F32StoreMem0_IS;
    type OpSs = crate::op::F32Store_SS;
    type OpSi = crate::op::F32Store_SI;
    type OpIs = crate::op::F32Store_IS;
    type OpIi = crate::op::F32Store_II;
    fn make_mem0_rr(ptr: crate::Reg, offset: crate::Offset, value: crate::Reg) -> ::core::option::Option<Self::OpMem0Rr> {
        ::core::option::Option::Some(Self::OpMem0Rr { ptr, offset, value })
    }
    fn make_mem0_rs(ptr: crate::Reg, offset: crate::Offset, value: crate::Stack) -> Self::OpMem0Rs {
        Self::OpMem0Rs { ptr, offset, value }
    }
    fn make_mem0_ri(ptr: crate::Reg, offset: crate::Offset, value: Self::Imm) -> Self::OpMem0Ri {
        Self::OpMem0Ri { ptr, offset, value }
    }
    fn make_mem0_sr(ptr: crate::Stack, offset: crate::Offset, value: crate::Reg) -> Self::OpMem0Sr {
        Self::OpMem0Sr { ptr, offset, value }
    }
    fn make_mem0_ss(ptr: crate::Stack, offset: crate::Offset, value: crate::Stack) -> Self::OpMem0Ss {
        Self::OpMem0Ss { ptr, offset, value }
    }
    fn make_mem0_si(ptr: crate::Stack, offset: crate::Offset, value: Self::Imm) -> Self::OpMem0Si {
        Self::OpMem0Si { ptr, offset, value }
    }
    fn make_mem0_ir(address: crate::Address, value: crate::Reg) -> Self::OpMem0Ir {
        Self::OpMem0Ir { address, value }
    }
    fn make_mem0_is(address: crate::Address, value: crate::Stack) -> Self::OpMem0Is {
        Self::OpMem0Is { address, value }
    }
    fn make_mem0_ii(address: crate::Address, value: Self::Imm) -> Self::OpMem0Ii {
        Self::OpMem0Ii { address, value }
    }
    fn make_ss(ptr: crate::Stack, offset: crate::Offset, value: crate::Stack, memory: crate::Memory) -> Self::OpSs {
        Self::OpSs { ptr, value, offset, memory }
    }
    fn make_si(ptr: crate::Stack, offset: crate::Offset, value: Self::Imm, memory: crate::Memory) -> Self::OpSi {
        Self::OpSi { ptr, value, offset, memory }
    }
    fn make_is(address: crate::Address, value: crate::Stack, memory: crate::Memory) -> Self::OpIs {
        Self::OpIs { address, value, memory }
    }
    fn make_ii(address: crate::Address, value: Self::Imm, memory: crate::Memory) -> Self::OpIi {
        Self::OpIi { address, value, memory }
    }
}
pub enum F64Store {}
impl crate::StoreOperator for F64Store {
    const NAME: &'static ::core::primitive::str = "F64Store";
    type Imm = ::core::primitive::f64;
    type OpMem0Rr = crate::op::F64StoreMem0_RR;
    type OpMem0Ri = crate::op::F64StoreMem0_RI;
    type OpMem0Rs = crate::op::F64StoreMem0_RS;
    type OpMem0Sr = crate::op::F64StoreMem0_SR;
    type OpMem0Si = crate::op::F64StoreMem0_SI;
    type OpMem0Ss = crate::op::F64StoreMem0_SS;
    type OpMem0Ir = crate::op::F64StoreMem0_IR;
    type OpMem0Ii = crate::op::F64StoreMem0_II;
    type OpMem0Is = crate::op::F64StoreMem0_IS;
    type OpSs = crate::op::F64Store_SS;
    type OpSi = crate::op::F64Store_SI;
    type OpIs = crate::op::F64Store_IS;
    type OpIi = crate::op::F64Store_II;
    fn make_mem0_rr(ptr: crate::Reg, offset: crate::Offset, value: crate::Reg) -> ::core::option::Option<Self::OpMem0Rr> {
        ::core::option::Option::Some(Self::OpMem0Rr { ptr, offset, value })
    }
    fn make_mem0_rs(ptr: crate::Reg, offset: crate::Offset, value: crate::Stack) -> Self::OpMem0Rs {
        Self::OpMem0Rs { ptr, offset, value }
    }
    fn make_mem0_ri(ptr: crate::Reg, offset: crate::Offset, value: Self::Imm) -> Self::OpMem0Ri {
        Self::OpMem0Ri { ptr, offset, value }
    }
    fn make_mem0_sr(ptr: crate::Stack, offset: crate::Offset, value: crate::Reg) -> Self::OpMem0Sr {
        Self::OpMem0Sr { ptr, offset, value }
    }
    fn make_mem0_ss(ptr: crate::Stack, offset: crate::Offset, value: crate::Stack) -> Self::OpMem0Ss {
        Self::OpMem0Ss { ptr, offset, value }
    }
    fn make_mem0_si(ptr: crate::Stack, offset: crate::Offset, value: Self::Imm) -> Self::OpMem0Si {
        Self::OpMem0Si { ptr, offset, value }
    }
    fn make_mem0_ir(address: crate::Address, value: crate::Reg) -> Self::OpMem0Ir {
        Self::OpMem0Ir { address, value }
    }
    fn make_mem0_is(address: crate::Address, value: crate::Stack) -> Self::OpMem0Is {
        Self::OpMem0Is { address, value }
    }
    fn make_mem0_ii(address: crate::Address, value: Self::Imm) -> Self::OpMem0Ii {
        Self::OpMem0Ii { address, value }
    }
    fn make_ss(ptr: crate::Stack, offset: crate::Offset, value: crate::Stack, memory: crate::Memory) -> Self::OpSs {
        Self::OpSs { ptr, value, offset, memory }
    }
    fn make_si(ptr: crate::Stack, offset: crate::Offset, value: Self::Imm, memory: crate::Memory) -> Self::OpSi {
        Self::OpSi { ptr, value, offset, memory }
    }
    fn make_is(address: crate::Address, value: crate::Stack, memory: crate::Memory) -> Self::OpIs {
        Self::OpIs { address, value, memory }
    }
    fn make_ii(address: crate::Address, value: Self::Imm, memory: crate::Memory) -> Self::OpIi {
        Self::OpIi { address, value, memory }
    }
}
pub enum I32Store8 {}
impl crate::StoreOperator for I32Store8 {
    const NAME: &'static ::core::primitive::str = "I32Store8";
    type Imm = ::core::primitive::i32;
    type OpMem0Rr = crate::utils::NoOp;
    type OpMem0Ri = crate::op::I32Store8Mem0_RI;
    type OpMem0Rs = crate::op::I32Store8Mem0_RS;
    type OpMem0Sr = crate::op::I32Store8Mem0_SR;
    type OpMem0Si = crate::op::I32Store8Mem0_SI;
    type OpMem0Ss = crate::op::I32Store8Mem0_SS;
    type OpMem0Ir = crate::op::I32Store8Mem0_IR;
    type OpMem0Ii = crate::op::I32Store8Mem0_II;
    type OpMem0Is = crate::op::I32Store8Mem0_IS;
    type OpSs = crate::op::I32Store8_SS;
    type OpSi = crate::op::I32Store8_SI;
    type OpIs = crate::op::I32Store8_IS;
    type OpIi = crate::op::I32Store8_II;
    fn make_mem0_rr(ptr: crate::Reg, offset: crate::Offset, value: crate::Reg) -> ::core::option::Option<Self::OpMem0Rr> {
        ::core::option::Option::None
    }
    fn make_mem0_rs(ptr: crate::Reg, offset: crate::Offset, value: crate::Stack) -> Self::OpMem0Rs {
        Self::OpMem0Rs { ptr, offset, value }
    }
    fn make_mem0_ri(ptr: crate::Reg, offset: crate::Offset, value: Self::Imm) -> Self::OpMem0Ri {
        Self::OpMem0Ri { ptr, offset, value }
    }
    fn make_mem0_sr(ptr: crate::Stack, offset: crate::Offset, value: crate::Reg) -> Self::OpMem0Sr {
        Self::OpMem0Sr { ptr, offset, value }
    }
    fn make_mem0_ss(ptr: crate::Stack, offset: crate::Offset, value: crate::Stack) -> Self::OpMem0Ss {
        Self::OpMem0Ss { ptr, offset, value }
    }
    fn make_mem0_si(ptr: crate::Stack, offset: crate::Offset, value: Self::Imm) -> Self::OpMem0Si {
        Self::OpMem0Si { ptr, offset, value }
    }
    fn make_mem0_ir(address: crate::Address, value: crate::Reg) -> Self::OpMem0Ir {
        Self::OpMem0Ir { address, value }
    }
    fn make_mem0_is(address: crate::Address, value: crate::Stack) -> Self::OpMem0Is {
        Self::OpMem0Is { address, value }
    }
    fn make_mem0_ii(address: crate::Address, value: Self::Imm) -> Self::OpMem0Ii {
        Self::OpMem0Ii { address, value }
    }
    fn make_ss(ptr: crate::Stack, offset: crate::Offset, value: crate::Stack, memory: crate::Memory) -> Self::OpSs {
        Self::OpSs { ptr, value, offset, memory }
    }
    fn make_si(ptr: crate::Stack, offset: crate::Offset, value: Self::Imm, memory: crate::Memory) -> Self::OpSi {
        Self::OpSi { ptr, value, offset, memory }
    }
    fn make_is(address: crate::Address, value: crate::Stack, memory: crate::Memory) -> Self::OpIs {
        Self::OpIs { address, value, memory }
    }
    fn make_ii(address: crate::Address, value: Self::Imm, memory: crate::Memory) -> Self::OpIi {
        Self::OpIi { address, value, memory }
    }
}
pub enum I64Store8 {}
impl crate::StoreOperator for I64Store8 {
    const NAME: &'static ::core::primitive::str = "I64Store8";
    type Imm = ::core::primitive::i64;
    type OpMem0Rr = crate::utils::NoOp;
    type OpMem0Ri = crate::op::I64Store8Mem0_RI;
    type OpMem0Rs = crate::op::I64Store8Mem0_RS;
    type OpMem0Sr = crate::op::I64Store8Mem0_SR;
    type OpMem0Si = crate::op::I64Store8Mem0_SI;
    type OpMem0Ss = crate::op::I64Store8Mem0_SS;
    type OpMem0Ir = crate::op::I64Store8Mem0_IR;
    type OpMem0Ii = crate::op::I64Store8Mem0_II;
    type OpMem0Is = crate::op::I64Store8Mem0_IS;
    type OpSs = crate::op::I64Store8_SS;
    type OpSi = crate::op::I64Store8_SI;
    type OpIs = crate::op::I64Store8_IS;
    type OpIi = crate::op::I64Store8_II;
    fn make_mem0_rr(ptr: crate::Reg, offset: crate::Offset, value: crate::Reg) -> ::core::option::Option<Self::OpMem0Rr> {
        ::core::option::Option::None
    }
    fn make_mem0_rs(ptr: crate::Reg, offset: crate::Offset, value: crate::Stack) -> Self::OpMem0Rs {
        Self::OpMem0Rs { ptr, offset, value }
    }
    fn make_mem0_ri(ptr: crate::Reg, offset: crate::Offset, value: Self::Imm) -> Self::OpMem0Ri {
        Self::OpMem0Ri { ptr, offset, value }
    }
    fn make_mem0_sr(ptr: crate::Stack, offset: crate::Offset, value: crate::Reg) -> Self::OpMem0Sr {
        Self::OpMem0Sr { ptr, offset, value }
    }
    fn make_mem0_ss(ptr: crate::Stack, offset: crate::Offset, value: crate::Stack) -> Self::OpMem0Ss {
        Self::OpMem0Ss { ptr, offset, value }
    }
    fn make_mem0_si(ptr: crate::Stack, offset: crate::Offset, value: Self::Imm) -> Self::OpMem0Si {
        Self::OpMem0Si { ptr, offset, value }
    }
    fn make_mem0_ir(address: crate::Address, value: crate::Reg) -> Self::OpMem0Ir {
        Self::OpMem0Ir { address, value }
    }
    fn make_mem0_is(address: crate::Address, value: crate::Stack) -> Self::OpMem0Is {
        Self::OpMem0Is { address, value }
    }
    fn make_mem0_ii(address: crate::Address, value: Self::Imm) -> Self::OpMem0Ii {
        Self::OpMem0Ii { address, value }
    }
    fn make_ss(ptr: crate::Stack, offset: crate::Offset, value: crate::Stack, memory: crate::Memory) -> Self::OpSs {
        Self::OpSs { ptr, value, offset, memory }
    }
    fn make_si(ptr: crate::Stack, offset: crate::Offset, value: Self::Imm, memory: crate::Memory) -> Self::OpSi {
        Self::OpSi { ptr, value, offset, memory }
    }
    fn make_is(address: crate::Address, value: crate::Stack, memory: crate::Memory) -> Self::OpIs {
        Self::OpIs { address, value, memory }
    }
    fn make_ii(address: crate::Address, value: Self::Imm, memory: crate::Memory) -> Self::OpIi {
        Self::OpIi { address, value, memory }
    }
}
pub enum I32Store16 {}
impl crate::StoreOperator for I32Store16 {
    const NAME: &'static ::core::primitive::str = "I32Store16";
    type Imm = ::core::primitive::i32;
    type OpMem0Rr = crate::utils::NoOp;
    type OpMem0Ri = crate::op::I32Store16Mem0_RI;
    type OpMem0Rs = crate::op::I32Store16Mem0_RS;
    type OpMem0Sr = crate::op::I32Store16Mem0_SR;
    type OpMem0Si = crate::op::I32Store16Mem0_SI;
    type OpMem0Ss = crate::op::I32Store16Mem0_SS;
    type OpMem0Ir = crate::op::I32Store16Mem0_IR;
    type OpMem0Ii = crate::op::I32Store16Mem0_II;
    type OpMem0Is = crate::op::I32Store16Mem0_IS;
    type OpSs = crate::op::I32Store16_SS;
    type OpSi = crate::op::I32Store16_SI;
    type OpIs = crate::op::I32Store16_IS;
    type OpIi = crate::op::I32Store16_II;
    fn make_mem0_rr(ptr: crate::Reg, offset: crate::Offset, value: crate::Reg) -> ::core::option::Option<Self::OpMem0Rr> {
        ::core::option::Option::None
    }
    fn make_mem0_rs(ptr: crate::Reg, offset: crate::Offset, value: crate::Stack) -> Self::OpMem0Rs {
        Self::OpMem0Rs { ptr, offset, value }
    }
    fn make_mem0_ri(ptr: crate::Reg, offset: crate::Offset, value: Self::Imm) -> Self::OpMem0Ri {
        Self::OpMem0Ri { ptr, offset, value }
    }
    fn make_mem0_sr(ptr: crate::Stack, offset: crate::Offset, value: crate::Reg) -> Self::OpMem0Sr {
        Self::OpMem0Sr { ptr, offset, value }
    }
    fn make_mem0_ss(ptr: crate::Stack, offset: crate::Offset, value: crate::Stack) -> Self::OpMem0Ss {
        Self::OpMem0Ss { ptr, offset, value }
    }
    fn make_mem0_si(ptr: crate::Stack, offset: crate::Offset, value: Self::Imm) -> Self::OpMem0Si {
        Self::OpMem0Si { ptr, offset, value }
    }
    fn make_mem0_ir(address: crate::Address, value: crate::Reg) -> Self::OpMem0Ir {
        Self::OpMem0Ir { address, value }
    }
    fn make_mem0_is(address: crate::Address, value: crate::Stack) -> Self::OpMem0Is {
        Self::OpMem0Is { address, value }
    }
    fn make_mem0_ii(address: crate::Address, value: Self::Imm) -> Self::OpMem0Ii {
        Self::OpMem0Ii { address, value }
    }
    fn make_ss(ptr: crate::Stack, offset: crate::Offset, value: crate::Stack, memory: crate::Memory) -> Self::OpSs {
        Self::OpSs { ptr, value, offset, memory }
    }
    fn make_si(ptr: crate::Stack, offset: crate::Offset, value: Self::Imm, memory: crate::Memory) -> Self::OpSi {
        Self::OpSi { ptr, value, offset, memory }
    }
    fn make_is(address: crate::Address, value: crate::Stack, memory: crate::Memory) -> Self::OpIs {
        Self::OpIs { address, value, memory }
    }
    fn make_ii(address: crate::Address, value: Self::Imm, memory: crate::Memory) -> Self::OpIi {
        Self::OpIi { address, value, memory }
    }
}
pub enum I64Store16 {}
impl crate::StoreOperator for I64Store16 {
    const NAME: &'static ::core::primitive::str = "I64Store16";
    type Imm = ::core::primitive::i64;
    type OpMem0Rr = crate::utils::NoOp;
    type OpMem0Ri = crate::op::I64Store16Mem0_RI;
    type OpMem0Rs = crate::op::I64Store16Mem0_RS;
    type OpMem0Sr = crate::op::I64Store16Mem0_SR;
    type OpMem0Si = crate::op::I64Store16Mem0_SI;
    type OpMem0Ss = crate::op::I64Store16Mem0_SS;
    type OpMem0Ir = crate::op::I64Store16Mem0_IR;
    type OpMem0Ii = crate::op::I64Store16Mem0_II;
    type OpMem0Is = crate::op::I64Store16Mem0_IS;
    type OpSs = crate::op::I64Store16_SS;
    type OpSi = crate::op::I64Store16_SI;
    type OpIs = crate::op::I64Store16_IS;
    type OpIi = crate::op::I64Store16_II;
    fn make_mem0_rr(ptr: crate::Reg, offset: crate::Offset, value: crate::Reg) -> ::core::option::Option<Self::OpMem0Rr> {
        ::core::option::Option::None
    }
    fn make_mem0_rs(ptr: crate::Reg, offset: crate::Offset, value: crate::Stack) -> Self::OpMem0Rs {
        Self::OpMem0Rs { ptr, offset, value }
    }
    fn make_mem0_ri(ptr: crate::Reg, offset: crate::Offset, value: Self::Imm) -> Self::OpMem0Ri {
        Self::OpMem0Ri { ptr, offset, value }
    }
    fn make_mem0_sr(ptr: crate::Stack, offset: crate::Offset, value: crate::Reg) -> Self::OpMem0Sr {
        Self::OpMem0Sr { ptr, offset, value }
    }
    fn make_mem0_ss(ptr: crate::Stack, offset: crate::Offset, value: crate::Stack) -> Self::OpMem0Ss {
        Self::OpMem0Ss { ptr, offset, value }
    }
    fn make_mem0_si(ptr: crate::Stack, offset: crate::Offset, value: Self::Imm) -> Self::OpMem0Si {
        Self::OpMem0Si { ptr, offset, value }
    }
    fn make_mem0_ir(address: crate::Address, value: crate::Reg) -> Self::OpMem0Ir {
        Self::OpMem0Ir { address, value }
    }
    fn make_mem0_is(address: crate::Address, value: crate::Stack) -> Self::OpMem0Is {
        Self::OpMem0Is { address, value }
    }
    fn make_mem0_ii(address: crate::Address, value: Self::Imm) -> Self::OpMem0Ii {
        Self::OpMem0Ii { address, value }
    }
    fn make_ss(ptr: crate::Stack, offset: crate::Offset, value: crate::Stack, memory: crate::Memory) -> Self::OpSs {
        Self::OpSs { ptr, value, offset, memory }
    }
    fn make_si(ptr: crate::Stack, offset: crate::Offset, value: Self::Imm, memory: crate::Memory) -> Self::OpSi {
        Self::OpSi { ptr, value, offset, memory }
    }
    fn make_is(address: crate::Address, value: crate::Stack, memory: crate::Memory) -> Self::OpIs {
        Self::OpIs { address, value, memory }
    }
    fn make_ii(address: crate::Address, value: Self::Imm, memory: crate::Memory) -> Self::OpIi {
        Self::OpIi { address, value, memory }
    }
}
pub enum I64Store32 {}
impl crate::StoreOperator for I64Store32 {
    const NAME: &'static ::core::primitive::str = "I64Store32";
    type Imm = ::core::primitive::i64;
    type OpMem0Rr = crate::utils::NoOp;
    type OpMem0Ri = crate::op::I64Store32Mem0_RI;
    type OpMem0Rs = crate::op::I64Store32Mem0_RS;
    type OpMem0Sr = crate::op::I64Store32Mem0_SR;
    type OpMem0Si = crate::op::I64Store32Mem0_SI;
    type OpMem0Ss = crate::op::I64Store32Mem0_SS;
    type OpMem0Ir = crate::op::I64Store32Mem0_IR;
    type OpMem0Ii = crate::op::I64Store32Mem0_II;
    type OpMem0Is = crate::op::I64Store32Mem0_IS;
    type OpSs = crate::op::I64Store32_SS;
    type OpSi = crate::op::I64Store32_SI;
    type OpIs = crate::op::I64Store32_IS;
    type OpIi = crate::op::I64Store32_II;
    fn make_mem0_rr(ptr: crate::Reg, offset: crate::Offset, value: crate::Reg) -> ::core::option::Option<Self::OpMem0Rr> {
        ::core::option::Option::None
    }
    fn make_mem0_rs(ptr: crate::Reg, offset: crate::Offset, value: crate::Stack) -> Self::OpMem0Rs {
        Self::OpMem0Rs { ptr, offset, value }
    }
    fn make_mem0_ri(ptr: crate::Reg, offset: crate::Offset, value: Self::Imm) -> Self::OpMem0Ri {
        Self::OpMem0Ri { ptr, offset, value }
    }
    fn make_mem0_sr(ptr: crate::Stack, offset: crate::Offset, value: crate::Reg) -> Self::OpMem0Sr {
        Self::OpMem0Sr { ptr, offset, value }
    }
    fn make_mem0_ss(ptr: crate::Stack, offset: crate::Offset, value: crate::Stack) -> Self::OpMem0Ss {
        Self::OpMem0Ss { ptr, offset, value }
    }
    fn make_mem0_si(ptr: crate::Stack, offset: crate::Offset, value: Self::Imm) -> Self::OpMem0Si {
        Self::OpMem0Si { ptr, offset, value }
    }
    fn make_mem0_ir(address: crate::Address, value: crate::Reg) -> Self::OpMem0Ir {
        Self::OpMem0Ir { address, value }
    }
    fn make_mem0_is(address: crate::Address, value: crate::Stack) -> Self::OpMem0Is {
        Self::OpMem0Is { address, value }
    }
    fn make_mem0_ii(address: crate::Address, value: Self::Imm) -> Self::OpMem0Ii {
        Self::OpMem0Ii { address, value }
    }
    fn make_ss(ptr: crate::Stack, offset: crate::Offset, value: crate::Stack, memory: crate::Memory) -> Self::OpSs {
        Self::OpSs { ptr, value, offset, memory }
    }
    fn make_si(ptr: crate::Stack, offset: crate::Offset, value: Self::Imm, memory: crate::Memory) -> Self::OpSi {
        Self::OpSi { ptr, value, offset, memory }
    }
    fn make_is(address: crate::Address, value: crate::Stack, memory: crate::Memory) -> Self::OpIs {
        Self::OpIs { address, value, memory }
    }
    fn make_ii(address: crate::Address, value: Self::Imm, memory: crate::Memory) -> Self::OpIi {
        Self::OpIi { address, value, memory }
    }
}
