// This file is automatically generated by the `build.rs` script.
//
// Do _not_ edit this file directly but change `build.rs` script logic instead.

pub enum I32LtSBranch {}
impl crate::CmpBranchOperator for I32LtSBranch {
    const NAME: &'static ::core::primitive::str = "I32LtSBranch";
    type Imm = ::core::primitive::i32;
    type OpIr = crate::op::I32LtSBranch_IR;
    type OpIs = crate::op::I32LtSBranch_IS;
    type OpRi = crate::op::I32LtSBranch_RI;
    type OpRs = crate::op::I32LtSBranch_RS;
    type OpSi = crate::op::I32LtSBranch_SI;
    type OpSr = crate::op::I32LtSBranch_SR;
    type OpSs = crate::op::I32LtSBranch_SS;
    fn make_ir(lhs: Self::Imm, rhs: crate::Reg, offset: crate::BranchOffset) -> Self::OpIr {
        Self::OpIr { lhs, rhs, offset }
    }
    fn make_is(lhs: Self::Imm, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpIs {
        Self::OpIs { lhs, rhs, offset }
    }
    fn make_ri(lhs: crate::Reg, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpRi {
        Self::OpRi { lhs, rhs, offset }
    }
    fn make_rs(lhs: crate::Reg, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpRs {
        Self::OpRs { lhs, rhs, offset }
    }
    fn make_si(lhs: crate::Stack, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpSi {
        Self::OpSi { lhs, rhs, offset }
    }
    fn make_sr(lhs: crate::Stack, rhs: crate::Reg, offset: crate::BranchOffset) -> Self::OpSr {
        Self::OpSr { lhs, rhs, offset }
    }
    fn make_ss(lhs: crate::Stack, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpSs {
        Self::OpSs { lhs, rhs, offset }
    }
}
pub enum I64LtSBranch {}
impl crate::CmpBranchOperator for I64LtSBranch {
    const NAME: &'static ::core::primitive::str = "I64LtSBranch";
    type Imm = ::core::primitive::i64;
    type OpIr = crate::op::I64LtSBranch_IR;
    type OpIs = crate::op::I64LtSBranch_IS;
    type OpRi = crate::op::I64LtSBranch_RI;
    type OpRs = crate::op::I64LtSBranch_RS;
    type OpSi = crate::op::I64LtSBranch_SI;
    type OpSr = crate::op::I64LtSBranch_SR;
    type OpSs = crate::op::I64LtSBranch_SS;
    fn make_ir(lhs: Self::Imm, rhs: crate::Reg, offset: crate::BranchOffset) -> Self::OpIr {
        Self::OpIr { lhs, rhs, offset }
    }
    fn make_is(lhs: Self::Imm, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpIs {
        Self::OpIs { lhs, rhs, offset }
    }
    fn make_ri(lhs: crate::Reg, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpRi {
        Self::OpRi { lhs, rhs, offset }
    }
    fn make_rs(lhs: crate::Reg, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpRs {
        Self::OpRs { lhs, rhs, offset }
    }
    fn make_si(lhs: crate::Stack, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpSi {
        Self::OpSi { lhs, rhs, offset }
    }
    fn make_sr(lhs: crate::Stack, rhs: crate::Reg, offset: crate::BranchOffset) -> Self::OpSr {
        Self::OpSr { lhs, rhs, offset }
    }
    fn make_ss(lhs: crate::Stack, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpSs {
        Self::OpSs { lhs, rhs, offset }
    }
}
pub enum I32LtUBranch {}
impl crate::CmpBranchOperator for I32LtUBranch {
    const NAME: &'static ::core::primitive::str = "I32LtUBranch";
    type Imm = ::core::primitive::i32;
    type OpIr = crate::op::I32LtUBranch_IR;
    type OpIs = crate::op::I32LtUBranch_IS;
    type OpRi = crate::op::I32LtUBranch_RI;
    type OpRs = crate::op::I32LtUBranch_RS;
    type OpSi = crate::op::I32LtUBranch_SI;
    type OpSr = crate::op::I32LtUBranch_SR;
    type OpSs = crate::op::I32LtUBranch_SS;
    fn make_ir(lhs: Self::Imm, rhs: crate::Reg, offset: crate::BranchOffset) -> Self::OpIr {
        Self::OpIr { lhs, rhs, offset }
    }
    fn make_is(lhs: Self::Imm, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpIs {
        Self::OpIs { lhs, rhs, offset }
    }
    fn make_ri(lhs: crate::Reg, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpRi {
        Self::OpRi { lhs, rhs, offset }
    }
    fn make_rs(lhs: crate::Reg, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpRs {
        Self::OpRs { lhs, rhs, offset }
    }
    fn make_si(lhs: crate::Stack, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpSi {
        Self::OpSi { lhs, rhs, offset }
    }
    fn make_sr(lhs: crate::Stack, rhs: crate::Reg, offset: crate::BranchOffset) -> Self::OpSr {
        Self::OpSr { lhs, rhs, offset }
    }
    fn make_ss(lhs: crate::Stack, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpSs {
        Self::OpSs { lhs, rhs, offset }
    }
}
pub enum I64LtUBranch {}
impl crate::CmpBranchOperator for I64LtUBranch {
    const NAME: &'static ::core::primitive::str = "I64LtUBranch";
    type Imm = ::core::primitive::i64;
    type OpIr = crate::op::I64LtUBranch_IR;
    type OpIs = crate::op::I64LtUBranch_IS;
    type OpRi = crate::op::I64LtUBranch_RI;
    type OpRs = crate::op::I64LtUBranch_RS;
    type OpSi = crate::op::I64LtUBranch_SI;
    type OpSr = crate::op::I64LtUBranch_SR;
    type OpSs = crate::op::I64LtUBranch_SS;
    fn make_ir(lhs: Self::Imm, rhs: crate::Reg, offset: crate::BranchOffset) -> Self::OpIr {
        Self::OpIr { lhs, rhs, offset }
    }
    fn make_is(lhs: Self::Imm, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpIs {
        Self::OpIs { lhs, rhs, offset }
    }
    fn make_ri(lhs: crate::Reg, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpRi {
        Self::OpRi { lhs, rhs, offset }
    }
    fn make_rs(lhs: crate::Reg, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpRs {
        Self::OpRs { lhs, rhs, offset }
    }
    fn make_si(lhs: crate::Stack, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpSi {
        Self::OpSi { lhs, rhs, offset }
    }
    fn make_sr(lhs: crate::Stack, rhs: crate::Reg, offset: crate::BranchOffset) -> Self::OpSr {
        Self::OpSr { lhs, rhs, offset }
    }
    fn make_ss(lhs: crate::Stack, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpSs {
        Self::OpSs { lhs, rhs, offset }
    }
}
pub enum I32LeSBranch {}
impl crate::CmpBranchOperator for I32LeSBranch {
    const NAME: &'static ::core::primitive::str = "I32LeSBranch";
    type Imm = ::core::primitive::i32;
    type OpIr = crate::op::I32LeSBranch_IR;
    type OpIs = crate::op::I32LeSBranch_IS;
    type OpRi = crate::op::I32LeSBranch_RI;
    type OpRs = crate::op::I32LeSBranch_RS;
    type OpSi = crate::op::I32LeSBranch_SI;
    type OpSr = crate::op::I32LeSBranch_SR;
    type OpSs = crate::op::I32LeSBranch_SS;
    fn make_ir(lhs: Self::Imm, rhs: crate::Reg, offset: crate::BranchOffset) -> Self::OpIr {
        Self::OpIr { lhs, rhs, offset }
    }
    fn make_is(lhs: Self::Imm, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpIs {
        Self::OpIs { lhs, rhs, offset }
    }
    fn make_ri(lhs: crate::Reg, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpRi {
        Self::OpRi { lhs, rhs, offset }
    }
    fn make_rs(lhs: crate::Reg, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpRs {
        Self::OpRs { lhs, rhs, offset }
    }
    fn make_si(lhs: crate::Stack, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpSi {
        Self::OpSi { lhs, rhs, offset }
    }
    fn make_sr(lhs: crate::Stack, rhs: crate::Reg, offset: crate::BranchOffset) -> Self::OpSr {
        Self::OpSr { lhs, rhs, offset }
    }
    fn make_ss(lhs: crate::Stack, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpSs {
        Self::OpSs { lhs, rhs, offset }
    }
}
pub enum I64LeSBranch {}
impl crate::CmpBranchOperator for I64LeSBranch {
    const NAME: &'static ::core::primitive::str = "I64LeSBranch";
    type Imm = ::core::primitive::i64;
    type OpIr = crate::op::I64LeSBranch_IR;
    type OpIs = crate::op::I64LeSBranch_IS;
    type OpRi = crate::op::I64LeSBranch_RI;
    type OpRs = crate::op::I64LeSBranch_RS;
    type OpSi = crate::op::I64LeSBranch_SI;
    type OpSr = crate::op::I64LeSBranch_SR;
    type OpSs = crate::op::I64LeSBranch_SS;
    fn make_ir(lhs: Self::Imm, rhs: crate::Reg, offset: crate::BranchOffset) -> Self::OpIr {
        Self::OpIr { lhs, rhs, offset }
    }
    fn make_is(lhs: Self::Imm, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpIs {
        Self::OpIs { lhs, rhs, offset }
    }
    fn make_ri(lhs: crate::Reg, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpRi {
        Self::OpRi { lhs, rhs, offset }
    }
    fn make_rs(lhs: crate::Reg, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpRs {
        Self::OpRs { lhs, rhs, offset }
    }
    fn make_si(lhs: crate::Stack, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpSi {
        Self::OpSi { lhs, rhs, offset }
    }
    fn make_sr(lhs: crate::Stack, rhs: crate::Reg, offset: crate::BranchOffset) -> Self::OpSr {
        Self::OpSr { lhs, rhs, offset }
    }
    fn make_ss(lhs: crate::Stack, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpSs {
        Self::OpSs { lhs, rhs, offset }
    }
}
pub enum I32LeUBranch {}
impl crate::CmpBranchOperator for I32LeUBranch {
    const NAME: &'static ::core::primitive::str = "I32LeUBranch";
    type Imm = ::core::primitive::i32;
    type OpIr = crate::op::I32LeUBranch_IR;
    type OpIs = crate::op::I32LeUBranch_IS;
    type OpRi = crate::op::I32LeUBranch_RI;
    type OpRs = crate::op::I32LeUBranch_RS;
    type OpSi = crate::op::I32LeUBranch_SI;
    type OpSr = crate::op::I32LeUBranch_SR;
    type OpSs = crate::op::I32LeUBranch_SS;
    fn make_ir(lhs: Self::Imm, rhs: crate::Reg, offset: crate::BranchOffset) -> Self::OpIr {
        Self::OpIr { lhs, rhs, offset }
    }
    fn make_is(lhs: Self::Imm, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpIs {
        Self::OpIs { lhs, rhs, offset }
    }
    fn make_ri(lhs: crate::Reg, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpRi {
        Self::OpRi { lhs, rhs, offset }
    }
    fn make_rs(lhs: crate::Reg, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpRs {
        Self::OpRs { lhs, rhs, offset }
    }
    fn make_si(lhs: crate::Stack, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpSi {
        Self::OpSi { lhs, rhs, offset }
    }
    fn make_sr(lhs: crate::Stack, rhs: crate::Reg, offset: crate::BranchOffset) -> Self::OpSr {
        Self::OpSr { lhs, rhs, offset }
    }
    fn make_ss(lhs: crate::Stack, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpSs {
        Self::OpSs { lhs, rhs, offset }
    }
}
pub enum I64LeUBranch {}
impl crate::CmpBranchOperator for I64LeUBranch {
    const NAME: &'static ::core::primitive::str = "I64LeUBranch";
    type Imm = ::core::primitive::i64;
    type OpIr = crate::op::I64LeUBranch_IR;
    type OpIs = crate::op::I64LeUBranch_IS;
    type OpRi = crate::op::I64LeUBranch_RI;
    type OpRs = crate::op::I64LeUBranch_RS;
    type OpSi = crate::op::I64LeUBranch_SI;
    type OpSr = crate::op::I64LeUBranch_SR;
    type OpSs = crate::op::I64LeUBranch_SS;
    fn make_ir(lhs: Self::Imm, rhs: crate::Reg, offset: crate::BranchOffset) -> Self::OpIr {
        Self::OpIr { lhs, rhs, offset }
    }
    fn make_is(lhs: Self::Imm, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpIs {
        Self::OpIs { lhs, rhs, offset }
    }
    fn make_ri(lhs: crate::Reg, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpRi {
        Self::OpRi { lhs, rhs, offset }
    }
    fn make_rs(lhs: crate::Reg, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpRs {
        Self::OpRs { lhs, rhs, offset }
    }
    fn make_si(lhs: crate::Stack, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpSi {
        Self::OpSi { lhs, rhs, offset }
    }
    fn make_sr(lhs: crate::Stack, rhs: crate::Reg, offset: crate::BranchOffset) -> Self::OpSr {
        Self::OpSr { lhs, rhs, offset }
    }
    fn make_ss(lhs: crate::Stack, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpSs {
        Self::OpSs { lhs, rhs, offset }
    }
}
pub enum F32LtBranch {}
impl crate::CmpBranchOperator for F32LtBranch {
    const NAME: &'static ::core::primitive::str = "F32LtBranch";
    type Imm = ::core::primitive::f32;
    type OpIr = crate::op::F32LtBranch_IR;
    type OpIs = crate::op::F32LtBranch_IS;
    type OpRi = crate::op::F32LtBranch_RI;
    type OpRs = crate::op::F32LtBranch_RS;
    type OpSi = crate::op::F32LtBranch_SI;
    type OpSr = crate::op::F32LtBranch_SR;
    type OpSs = crate::op::F32LtBranch_SS;
    fn make_ir(lhs: Self::Imm, rhs: crate::Reg, offset: crate::BranchOffset) -> Self::OpIr {
        Self::OpIr { lhs, rhs, offset }
    }
    fn make_is(lhs: Self::Imm, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpIs {
        Self::OpIs { lhs, rhs, offset }
    }
    fn make_ri(lhs: crate::Reg, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpRi {
        Self::OpRi { lhs, rhs, offset }
    }
    fn make_rs(lhs: crate::Reg, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpRs {
        Self::OpRs { lhs, rhs, offset }
    }
    fn make_si(lhs: crate::Stack, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpSi {
        Self::OpSi { lhs, rhs, offset }
    }
    fn make_sr(lhs: crate::Stack, rhs: crate::Reg, offset: crate::BranchOffset) -> Self::OpSr {
        Self::OpSr { lhs, rhs, offset }
    }
    fn make_ss(lhs: crate::Stack, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpSs {
        Self::OpSs { lhs, rhs, offset }
    }
}
pub enum F64LtBranch {}
impl crate::CmpBranchOperator for F64LtBranch {
    const NAME: &'static ::core::primitive::str = "F64LtBranch";
    type Imm = ::core::primitive::f64;
    type OpIr = crate::op::F64LtBranch_IR;
    type OpIs = crate::op::F64LtBranch_IS;
    type OpRi = crate::op::F64LtBranch_RI;
    type OpRs = crate::op::F64LtBranch_RS;
    type OpSi = crate::op::F64LtBranch_SI;
    type OpSr = crate::op::F64LtBranch_SR;
    type OpSs = crate::op::F64LtBranch_SS;
    fn make_ir(lhs: Self::Imm, rhs: crate::Reg, offset: crate::BranchOffset) -> Self::OpIr {
        Self::OpIr { lhs, rhs, offset }
    }
    fn make_is(lhs: Self::Imm, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpIs {
        Self::OpIs { lhs, rhs, offset }
    }
    fn make_ri(lhs: crate::Reg, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpRi {
        Self::OpRi { lhs, rhs, offset }
    }
    fn make_rs(lhs: crate::Reg, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpRs {
        Self::OpRs { lhs, rhs, offset }
    }
    fn make_si(lhs: crate::Stack, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpSi {
        Self::OpSi { lhs, rhs, offset }
    }
    fn make_sr(lhs: crate::Stack, rhs: crate::Reg, offset: crate::BranchOffset) -> Self::OpSr {
        Self::OpSr { lhs, rhs, offset }
    }
    fn make_ss(lhs: crate::Stack, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpSs {
        Self::OpSs { lhs, rhs, offset }
    }
}
pub enum F32LeBranch {}
impl crate::CmpBranchOperator for F32LeBranch {
    const NAME: &'static ::core::primitive::str = "F32LeBranch";
    type Imm = ::core::primitive::f32;
    type OpIr = crate::op::F32LeBranch_IR;
    type OpIs = crate::op::F32LeBranch_IS;
    type OpRi = crate::op::F32LeBranch_RI;
    type OpRs = crate::op::F32LeBranch_RS;
    type OpSi = crate::op::F32LeBranch_SI;
    type OpSr = crate::op::F32LeBranch_SR;
    type OpSs = crate::op::F32LeBranch_SS;
    fn make_ir(lhs: Self::Imm, rhs: crate::Reg, offset: crate::BranchOffset) -> Self::OpIr {
        Self::OpIr { lhs, rhs, offset }
    }
    fn make_is(lhs: Self::Imm, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpIs {
        Self::OpIs { lhs, rhs, offset }
    }
    fn make_ri(lhs: crate::Reg, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpRi {
        Self::OpRi { lhs, rhs, offset }
    }
    fn make_rs(lhs: crate::Reg, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpRs {
        Self::OpRs { lhs, rhs, offset }
    }
    fn make_si(lhs: crate::Stack, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpSi {
        Self::OpSi { lhs, rhs, offset }
    }
    fn make_sr(lhs: crate::Stack, rhs: crate::Reg, offset: crate::BranchOffset) -> Self::OpSr {
        Self::OpSr { lhs, rhs, offset }
    }
    fn make_ss(lhs: crate::Stack, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpSs {
        Self::OpSs { lhs, rhs, offset }
    }
}
pub enum F64LeBranch {}
impl crate::CmpBranchOperator for F64LeBranch {
    const NAME: &'static ::core::primitive::str = "F64LeBranch";
    type Imm = ::core::primitive::f64;
    type OpIr = crate::op::F64LeBranch_IR;
    type OpIs = crate::op::F64LeBranch_IS;
    type OpRi = crate::op::F64LeBranch_RI;
    type OpRs = crate::op::F64LeBranch_RS;
    type OpSi = crate::op::F64LeBranch_SI;
    type OpSr = crate::op::F64LeBranch_SR;
    type OpSs = crate::op::F64LeBranch_SS;
    fn make_ir(lhs: Self::Imm, rhs: crate::Reg, offset: crate::BranchOffset) -> Self::OpIr {
        Self::OpIr { lhs, rhs, offset }
    }
    fn make_is(lhs: Self::Imm, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpIs {
        Self::OpIs { lhs, rhs, offset }
    }
    fn make_ri(lhs: crate::Reg, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpRi {
        Self::OpRi { lhs, rhs, offset }
    }
    fn make_rs(lhs: crate::Reg, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpRs {
        Self::OpRs { lhs, rhs, offset }
    }
    fn make_si(lhs: crate::Stack, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpSi {
        Self::OpSi { lhs, rhs, offset }
    }
    fn make_sr(lhs: crate::Stack, rhs: crate::Reg, offset: crate::BranchOffset) -> Self::OpSr {
        Self::OpSr { lhs, rhs, offset }
    }
    fn make_ss(lhs: crate::Stack, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpSs {
        Self::OpSs { lhs, rhs, offset }
    }
}
