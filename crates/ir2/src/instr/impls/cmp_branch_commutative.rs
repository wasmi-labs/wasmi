// This file is automatically generated by the `build.rs` script.
//
// Do _not_ edit this file directly but change `build.rs` script logic instead.

pub enum I32EqBranch {}
impl crate::CmpBranchCommutativeOperator for I32EqBranch {
    const NAME: &'static ::core::primitive::str = "I32EqBranch";
    type Imm = ::core::primitive::i32;
    type OpRi = crate::op::I32EqBranch_RI;
    type OpRs = crate::op::I32EqBranch_RS;
    type OpSi = crate::op::I32EqBranch_SI;
    type OpSs = crate::op::I32EqBranch_SS;
    fn make_ri(lhs: crate::Reg, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpRi {
        Self::OpRi { lhs, rhs, offset }
    }
    fn make_rs(lhs: crate::Reg, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpRs {
        Self::OpRs { lhs, rhs, offset }
    }
    fn make_si(lhs: crate::Stack, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpSi {
        Self::OpSi { lhs, rhs, offset }
    }
    fn make_ss(lhs: crate::Stack, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpSs {
        Self::OpSs { lhs, rhs, offset }
    }
}
pub enum I64EqBranch {}
impl crate::CmpBranchCommutativeOperator for I64EqBranch {
    const NAME: &'static ::core::primitive::str = "I64EqBranch";
    type Imm = ::core::primitive::i64;
    type OpRi = crate::op::I64EqBranch_RI;
    type OpRs = crate::op::I64EqBranch_RS;
    type OpSi = crate::op::I64EqBranch_SI;
    type OpSs = crate::op::I64EqBranch_SS;
    fn make_ri(lhs: crate::Reg, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpRi {
        Self::OpRi { lhs, rhs, offset }
    }
    fn make_rs(lhs: crate::Reg, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpRs {
        Self::OpRs { lhs, rhs, offset }
    }
    fn make_si(lhs: crate::Stack, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpSi {
        Self::OpSi { lhs, rhs, offset }
    }
    fn make_ss(lhs: crate::Stack, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpSs {
        Self::OpSs { lhs, rhs, offset }
    }
}
pub enum F32EqBranch {}
impl crate::CmpBranchCommutativeOperator for F32EqBranch {
    const NAME: &'static ::core::primitive::str = "F32EqBranch";
    type Imm = ::core::primitive::f32;
    type OpRi = crate::op::F32EqBranch_RI;
    type OpRs = crate::op::F32EqBranch_RS;
    type OpSi = crate::op::F32EqBranch_SI;
    type OpSs = crate::op::F32EqBranch_SS;
    fn make_ri(lhs: crate::Reg, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpRi {
        Self::OpRi { lhs, rhs, offset }
    }
    fn make_rs(lhs: crate::Reg, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpRs {
        Self::OpRs { lhs, rhs, offset }
    }
    fn make_si(lhs: crate::Stack, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpSi {
        Self::OpSi { lhs, rhs, offset }
    }
    fn make_ss(lhs: crate::Stack, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpSs {
        Self::OpSs { lhs, rhs, offset }
    }
}
pub enum F64EqBranch {}
impl crate::CmpBranchCommutativeOperator for F64EqBranch {
    const NAME: &'static ::core::primitive::str = "F64EqBranch";
    type Imm = ::core::primitive::f64;
    type OpRi = crate::op::F64EqBranch_RI;
    type OpRs = crate::op::F64EqBranch_RS;
    type OpSi = crate::op::F64EqBranch_SI;
    type OpSs = crate::op::F64EqBranch_SS;
    fn make_ri(lhs: crate::Reg, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpRi {
        Self::OpRi { lhs, rhs, offset }
    }
    fn make_rs(lhs: crate::Reg, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpRs {
        Self::OpRs { lhs, rhs, offset }
    }
    fn make_si(lhs: crate::Stack, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpSi {
        Self::OpSi { lhs, rhs, offset }
    }
    fn make_ss(lhs: crate::Stack, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpSs {
        Self::OpSs { lhs, rhs, offset }
    }
}
pub enum I32NeBranch {}
impl crate::CmpBranchCommutativeOperator for I32NeBranch {
    const NAME: &'static ::core::primitive::str = "I32NeBranch";
    type Imm = ::core::primitive::i32;
    type OpRi = crate::op::I32NeBranch_RI;
    type OpRs = crate::op::I32NeBranch_RS;
    type OpSi = crate::op::I32NeBranch_SI;
    type OpSs = crate::op::I32NeBranch_SS;
    fn make_ri(lhs: crate::Reg, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpRi {
        Self::OpRi { lhs, rhs, offset }
    }
    fn make_rs(lhs: crate::Reg, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpRs {
        Self::OpRs { lhs, rhs, offset }
    }
    fn make_si(lhs: crate::Stack, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpSi {
        Self::OpSi { lhs, rhs, offset }
    }
    fn make_ss(lhs: crate::Stack, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpSs {
        Self::OpSs { lhs, rhs, offset }
    }
}
pub enum I64NeBranch {}
impl crate::CmpBranchCommutativeOperator for I64NeBranch {
    const NAME: &'static ::core::primitive::str = "I64NeBranch";
    type Imm = ::core::primitive::i64;
    type OpRi = crate::op::I64NeBranch_RI;
    type OpRs = crate::op::I64NeBranch_RS;
    type OpSi = crate::op::I64NeBranch_SI;
    type OpSs = crate::op::I64NeBranch_SS;
    fn make_ri(lhs: crate::Reg, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpRi {
        Self::OpRi { lhs, rhs, offset }
    }
    fn make_rs(lhs: crate::Reg, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpRs {
        Self::OpRs { lhs, rhs, offset }
    }
    fn make_si(lhs: crate::Stack, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpSi {
        Self::OpSi { lhs, rhs, offset }
    }
    fn make_ss(lhs: crate::Stack, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpSs {
        Self::OpSs { lhs, rhs, offset }
    }
}
pub enum F32NeBranch {}
impl crate::CmpBranchCommutativeOperator for F32NeBranch {
    const NAME: &'static ::core::primitive::str = "F32NeBranch";
    type Imm = ::core::primitive::f32;
    type OpRi = crate::op::F32NeBranch_RI;
    type OpRs = crate::op::F32NeBranch_RS;
    type OpSi = crate::op::F32NeBranch_SI;
    type OpSs = crate::op::F32NeBranch_SS;
    fn make_ri(lhs: crate::Reg, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpRi {
        Self::OpRi { lhs, rhs, offset }
    }
    fn make_rs(lhs: crate::Reg, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpRs {
        Self::OpRs { lhs, rhs, offset }
    }
    fn make_si(lhs: crate::Stack, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpSi {
        Self::OpSi { lhs, rhs, offset }
    }
    fn make_ss(lhs: crate::Stack, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpSs {
        Self::OpSs { lhs, rhs, offset }
    }
}
pub enum F64NeBranch {}
impl crate::CmpBranchCommutativeOperator for F64NeBranch {
    const NAME: &'static ::core::primitive::str = "F64NeBranch";
    type Imm = ::core::primitive::f64;
    type OpRi = crate::op::F64NeBranch_RI;
    type OpRs = crate::op::F64NeBranch_RS;
    type OpSi = crate::op::F64NeBranch_SI;
    type OpSs = crate::op::F64NeBranch_SS;
    fn make_ri(lhs: crate::Reg, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpRi {
        Self::OpRi { lhs, rhs, offset }
    }
    fn make_rs(lhs: crate::Reg, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpRs {
        Self::OpRs { lhs, rhs, offset }
    }
    fn make_si(lhs: crate::Stack, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpSi {
        Self::OpSi { lhs, rhs, offset }
    }
    fn make_ss(lhs: crate::Stack, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpSs {
        Self::OpSs { lhs, rhs, offset }
    }
}
pub enum I32AndBranch {}
impl crate::CmpBranchCommutativeOperator for I32AndBranch {
    const NAME: &'static ::core::primitive::str = "I32AndBranch";
    type Imm = ::core::primitive::i32;
    type OpRi = crate::op::I32AndBranch_RI;
    type OpRs = crate::op::I32AndBranch_RS;
    type OpSi = crate::op::I32AndBranch_SI;
    type OpSs = crate::op::I32AndBranch_SS;
    fn make_ri(lhs: crate::Reg, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpRi {
        Self::OpRi { lhs, rhs, offset }
    }
    fn make_rs(lhs: crate::Reg, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpRs {
        Self::OpRs { lhs, rhs, offset }
    }
    fn make_si(lhs: crate::Stack, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpSi {
        Self::OpSi { lhs, rhs, offset }
    }
    fn make_ss(lhs: crate::Stack, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpSs {
        Self::OpSs { lhs, rhs, offset }
    }
}
pub enum I64AndBranch {}
impl crate::CmpBranchCommutativeOperator for I64AndBranch {
    const NAME: &'static ::core::primitive::str = "I64AndBranch";
    type Imm = ::core::primitive::i64;
    type OpRi = crate::op::I64AndBranch_RI;
    type OpRs = crate::op::I64AndBranch_RS;
    type OpSi = crate::op::I64AndBranch_SI;
    type OpSs = crate::op::I64AndBranch_SS;
    fn make_ri(lhs: crate::Reg, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpRi {
        Self::OpRi { lhs, rhs, offset }
    }
    fn make_rs(lhs: crate::Reg, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpRs {
        Self::OpRs { lhs, rhs, offset }
    }
    fn make_si(lhs: crate::Stack, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpSi {
        Self::OpSi { lhs, rhs, offset }
    }
    fn make_ss(lhs: crate::Stack, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpSs {
        Self::OpSs { lhs, rhs, offset }
    }
}
pub enum I32OrBranch {}
impl crate::CmpBranchCommutativeOperator for I32OrBranch {
    const NAME: &'static ::core::primitive::str = "I32OrBranch";
    type Imm = ::core::primitive::i32;
    type OpRi = crate::op::I32OrBranch_RI;
    type OpRs = crate::op::I32OrBranch_RS;
    type OpSi = crate::op::I32OrBranch_SI;
    type OpSs = crate::op::I32OrBranch_SS;
    fn make_ri(lhs: crate::Reg, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpRi {
        Self::OpRi { lhs, rhs, offset }
    }
    fn make_rs(lhs: crate::Reg, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpRs {
        Self::OpRs { lhs, rhs, offset }
    }
    fn make_si(lhs: crate::Stack, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpSi {
        Self::OpSi { lhs, rhs, offset }
    }
    fn make_ss(lhs: crate::Stack, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpSs {
        Self::OpSs { lhs, rhs, offset }
    }
}
pub enum I64OrBranch {}
impl crate::CmpBranchCommutativeOperator for I64OrBranch {
    const NAME: &'static ::core::primitive::str = "I64OrBranch";
    type Imm = ::core::primitive::i64;
    type OpRi = crate::op::I64OrBranch_RI;
    type OpRs = crate::op::I64OrBranch_RS;
    type OpSi = crate::op::I64OrBranch_SI;
    type OpSs = crate::op::I64OrBranch_SS;
    fn make_ri(lhs: crate::Reg, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpRi {
        Self::OpRi { lhs, rhs, offset }
    }
    fn make_rs(lhs: crate::Reg, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpRs {
        Self::OpRs { lhs, rhs, offset }
    }
    fn make_si(lhs: crate::Stack, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpSi {
        Self::OpSi { lhs, rhs, offset }
    }
    fn make_ss(lhs: crate::Stack, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpSs {
        Self::OpSs { lhs, rhs, offset }
    }
}
pub enum I32XorBranch {}
impl crate::CmpBranchCommutativeOperator for I32XorBranch {
    const NAME: &'static ::core::primitive::str = "I32XorBranch";
    type Imm = ::core::primitive::i32;
    type OpRi = crate::op::I32XorBranch_RI;
    type OpRs = crate::op::I32XorBranch_RS;
    type OpSi = crate::op::I32XorBranch_SI;
    type OpSs = crate::op::I32XorBranch_SS;
    fn make_ri(lhs: crate::Reg, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpRi {
        Self::OpRi { lhs, rhs, offset }
    }
    fn make_rs(lhs: crate::Reg, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpRs {
        Self::OpRs { lhs, rhs, offset }
    }
    fn make_si(lhs: crate::Stack, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpSi {
        Self::OpSi { lhs, rhs, offset }
    }
    fn make_ss(lhs: crate::Stack, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpSs {
        Self::OpSs { lhs, rhs, offset }
    }
}
pub enum I64XorBranch {}
impl crate::CmpBranchCommutativeOperator for I64XorBranch {
    const NAME: &'static ::core::primitive::str = "I64XorBranch";
    type Imm = ::core::primitive::i64;
    type OpRi = crate::op::I64XorBranch_RI;
    type OpRs = crate::op::I64XorBranch_RS;
    type OpSi = crate::op::I64XorBranch_SI;
    type OpSs = crate::op::I64XorBranch_SS;
    fn make_ri(lhs: crate::Reg, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpRi {
        Self::OpRi { lhs, rhs, offset }
    }
    fn make_rs(lhs: crate::Reg, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpRs {
        Self::OpRs { lhs, rhs, offset }
    }
    fn make_si(lhs: crate::Stack, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpSi {
        Self::OpSi { lhs, rhs, offset }
    }
    fn make_ss(lhs: crate::Stack, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpSs {
        Self::OpSs { lhs, rhs, offset }
    }
}
pub enum I32NotAndBranch {}
impl crate::CmpBranchCommutativeOperator for I32NotAndBranch {
    const NAME: &'static ::core::primitive::str = "I32NotAndBranch";
    type Imm = ::core::primitive::i32;
    type OpRi = crate::op::I32NotAndBranch_RI;
    type OpRs = crate::op::I32NotAndBranch_RS;
    type OpSi = crate::op::I32NotAndBranch_SI;
    type OpSs = crate::op::I32NotAndBranch_SS;
    fn make_ri(lhs: crate::Reg, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpRi {
        Self::OpRi { lhs, rhs, offset }
    }
    fn make_rs(lhs: crate::Reg, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpRs {
        Self::OpRs { lhs, rhs, offset }
    }
    fn make_si(lhs: crate::Stack, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpSi {
        Self::OpSi { lhs, rhs, offset }
    }
    fn make_ss(lhs: crate::Stack, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpSs {
        Self::OpSs { lhs, rhs, offset }
    }
}
pub enum I64NotAndBranch {}
impl crate::CmpBranchCommutativeOperator for I64NotAndBranch {
    const NAME: &'static ::core::primitive::str = "I64NotAndBranch";
    type Imm = ::core::primitive::i64;
    type OpRi = crate::op::I64NotAndBranch_RI;
    type OpRs = crate::op::I64NotAndBranch_RS;
    type OpSi = crate::op::I64NotAndBranch_SI;
    type OpSs = crate::op::I64NotAndBranch_SS;
    fn make_ri(lhs: crate::Reg, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpRi {
        Self::OpRi { lhs, rhs, offset }
    }
    fn make_rs(lhs: crate::Reg, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpRs {
        Self::OpRs { lhs, rhs, offset }
    }
    fn make_si(lhs: crate::Stack, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpSi {
        Self::OpSi { lhs, rhs, offset }
    }
    fn make_ss(lhs: crate::Stack, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpSs {
        Self::OpSs { lhs, rhs, offset }
    }
}
pub enum I32NotOrBranch {}
impl crate::CmpBranchCommutativeOperator for I32NotOrBranch {
    const NAME: &'static ::core::primitive::str = "I32NotOrBranch";
    type Imm = ::core::primitive::i32;
    type OpRi = crate::op::I32NotOrBranch_RI;
    type OpRs = crate::op::I32NotOrBranch_RS;
    type OpSi = crate::op::I32NotOrBranch_SI;
    type OpSs = crate::op::I32NotOrBranch_SS;
    fn make_ri(lhs: crate::Reg, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpRi {
        Self::OpRi { lhs, rhs, offset }
    }
    fn make_rs(lhs: crate::Reg, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpRs {
        Self::OpRs { lhs, rhs, offset }
    }
    fn make_si(lhs: crate::Stack, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpSi {
        Self::OpSi { lhs, rhs, offset }
    }
    fn make_ss(lhs: crate::Stack, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpSs {
        Self::OpSs { lhs, rhs, offset }
    }
}
pub enum I64NotOrBranch {}
impl crate::CmpBranchCommutativeOperator for I64NotOrBranch {
    const NAME: &'static ::core::primitive::str = "I64NotOrBranch";
    type Imm = ::core::primitive::i64;
    type OpRi = crate::op::I64NotOrBranch_RI;
    type OpRs = crate::op::I64NotOrBranch_RS;
    type OpSi = crate::op::I64NotOrBranch_SI;
    type OpSs = crate::op::I64NotOrBranch_SS;
    fn make_ri(lhs: crate::Reg, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpRi {
        Self::OpRi { lhs, rhs, offset }
    }
    fn make_rs(lhs: crate::Reg, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpRs {
        Self::OpRs { lhs, rhs, offset }
    }
    fn make_si(lhs: crate::Stack, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpSi {
        Self::OpSi { lhs, rhs, offset }
    }
    fn make_ss(lhs: crate::Stack, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpSs {
        Self::OpSs { lhs, rhs, offset }
    }
}
pub enum I32NotXorBranch {}
impl crate::CmpBranchCommutativeOperator for I32NotXorBranch {
    const NAME: &'static ::core::primitive::str = "I32NotXorBranch";
    type Imm = ::core::primitive::i32;
    type OpRi = crate::op::I32NotXorBranch_RI;
    type OpRs = crate::op::I32NotXorBranch_RS;
    type OpSi = crate::op::I32NotXorBranch_SI;
    type OpSs = crate::op::I32NotXorBranch_SS;
    fn make_ri(lhs: crate::Reg, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpRi {
        Self::OpRi { lhs, rhs, offset }
    }
    fn make_rs(lhs: crate::Reg, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpRs {
        Self::OpRs { lhs, rhs, offset }
    }
    fn make_si(lhs: crate::Stack, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpSi {
        Self::OpSi { lhs, rhs, offset }
    }
    fn make_ss(lhs: crate::Stack, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpSs {
        Self::OpSs { lhs, rhs, offset }
    }
}
pub enum I64NotXorBranch {}
impl crate::CmpBranchCommutativeOperator for I64NotXorBranch {
    const NAME: &'static ::core::primitive::str = "I64NotXorBranch";
    type Imm = ::core::primitive::i64;
    type OpRi = crate::op::I64NotXorBranch_RI;
    type OpRs = crate::op::I64NotXorBranch_RS;
    type OpSi = crate::op::I64NotXorBranch_SI;
    type OpSs = crate::op::I64NotXorBranch_SS;
    fn make_ri(lhs: crate::Reg, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpRi {
        Self::OpRi { lhs, rhs, offset }
    }
    fn make_rs(lhs: crate::Reg, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpRs {
        Self::OpRs { lhs, rhs, offset }
    }
    fn make_si(lhs: crate::Stack, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpSi {
        Self::OpSi { lhs, rhs, offset }
    }
    fn make_ss(lhs: crate::Stack, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpSs {
        Self::OpSs { lhs, rhs, offset }
    }
}
