// This file is automatically generated by the `build.rs` script.
//
// Do _not_ edit this file directly but change `build.rs` script logic instead.

pub enum I32EqBranch {}
impl crate::CmpBranchCommutativeOperator for I32EqBranch {
    const NAME: &'static ::core::primitive::str = "I32EqBranch";
    type Imm = ::core::primitive::i32;
    type OpRi = crate::op::I32EqBranch_RI;
    type OpRs = crate::op::I32EqBranch_RS;
    type OpSi = crate::op::I32EqBranch_SI;
    type OpSs = crate::op::I32EqBranch_SS;
    fn make_ri(lhs: crate::Reg, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpRi {
        Self::OpRi { lhs, rhs, offset }
    }
    fn make_rs(lhs: crate::Reg, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpRs {
        Self::OpRs { lhs, rhs, offset }
    }
    fn make_si(lhs: crate::Stack, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpSi {
        Self::OpSi { lhs, rhs, offset }
    }
    fn make_ss(lhs: crate::Stack, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpSs {
        Self::OpSs { lhs, rhs, offset }
    }
}
pub enum I64EqBranch {}
impl crate::CmpBranchCommutativeOperator for I64EqBranch {
    const NAME: &'static ::core::primitive::str = "I64EqBranch";
    type Imm = ::core::primitive::i64;
    type OpRi = crate::op::I64EqBranch_RI;
    type OpRs = crate::op::I64EqBranch_RS;
    type OpSi = crate::op::I64EqBranch_SI;
    type OpSs = crate::op::I64EqBranch_SS;
    fn make_ri(lhs: crate::Reg, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpRi {
        Self::OpRi { lhs, rhs, offset }
    }
    fn make_rs(lhs: crate::Reg, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpRs {
        Self::OpRs { lhs, rhs, offset }
    }
    fn make_si(lhs: crate::Stack, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpSi {
        Self::OpSi { lhs, rhs, offset }
    }
    fn make_ss(lhs: crate::Stack, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpSs {
        Self::OpSs { lhs, rhs, offset }
    }
}
pub enum F32EqBranch {}
impl crate::CmpBranchCommutativeOperator for F32EqBranch {
    const NAME: &'static ::core::primitive::str = "F32EqBranch";
    type Imm = ::core::primitive::f32;
    type OpRi = crate::op::F32EqBranch_RI;
    type OpRs = crate::op::F32EqBranch_RS;
    type OpSi = crate::op::F32EqBranch_SI;
    type OpSs = crate::op::F32EqBranch_SS;
    fn make_ri(lhs: crate::Reg, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpRi {
        Self::OpRi { lhs, rhs, offset }
    }
    fn make_rs(lhs: crate::Reg, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpRs {
        Self::OpRs { lhs, rhs, offset }
    }
    fn make_si(lhs: crate::Stack, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpSi {
        Self::OpSi { lhs, rhs, offset }
    }
    fn make_ss(lhs: crate::Stack, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpSs {
        Self::OpSs { lhs, rhs, offset }
    }
}
pub enum F64EqBranch {}
impl crate::CmpBranchCommutativeOperator for F64EqBranch {
    const NAME: &'static ::core::primitive::str = "F64EqBranch";
    type Imm = ::core::primitive::f64;
    type OpRi = crate::op::F64EqBranch_RI;
    type OpRs = crate::op::F64EqBranch_RS;
    type OpSi = crate::op::F64EqBranch_SI;
    type OpSs = crate::op::F64EqBranch_SS;
    fn make_ri(lhs: crate::Reg, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpRi {
        Self::OpRi { lhs, rhs, offset }
    }
    fn make_rs(lhs: crate::Reg, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpRs {
        Self::OpRs { lhs, rhs, offset }
    }
    fn make_si(lhs: crate::Stack, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpSi {
        Self::OpSi { lhs, rhs, offset }
    }
    fn make_ss(lhs: crate::Stack, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpSs {
        Self::OpSs { lhs, rhs, offset }
    }
}
pub enum I32NeBranch {}
impl crate::CmpBranchCommutativeOperator for I32NeBranch {
    const NAME: &'static ::core::primitive::str = "I32NeBranch";
    type Imm = ::core::primitive::i32;
    type OpRi = crate::op::I32NeBranch_RI;
    type OpRs = crate::op::I32NeBranch_RS;
    type OpSi = crate::op::I32NeBranch_SI;
    type OpSs = crate::op::I32NeBranch_SS;
    fn make_ri(lhs: crate::Reg, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpRi {
        Self::OpRi { lhs, rhs, offset }
    }
    fn make_rs(lhs: crate::Reg, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpRs {
        Self::OpRs { lhs, rhs, offset }
    }
    fn make_si(lhs: crate::Stack, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpSi {
        Self::OpSi { lhs, rhs, offset }
    }
    fn make_ss(lhs: crate::Stack, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpSs {
        Self::OpSs { lhs, rhs, offset }
    }
}
pub enum I64NeBranch {}
impl crate::CmpBranchCommutativeOperator for I64NeBranch {
    const NAME: &'static ::core::primitive::str = "I64NeBranch";
    type Imm = ::core::primitive::i64;
    type OpRi = crate::op::I64NeBranch_RI;
    type OpRs = crate::op::I64NeBranch_RS;
    type OpSi = crate::op::I64NeBranch_SI;
    type OpSs = crate::op::I64NeBranch_SS;
    fn make_ri(lhs: crate::Reg, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpRi {
        Self::OpRi { lhs, rhs, offset }
    }
    fn make_rs(lhs: crate::Reg, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpRs {
        Self::OpRs { lhs, rhs, offset }
    }
    fn make_si(lhs: crate::Stack, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpSi {
        Self::OpSi { lhs, rhs, offset }
    }
    fn make_ss(lhs: crate::Stack, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpSs {
        Self::OpSs { lhs, rhs, offset }
    }
}
pub enum F32NeBranch {}
impl crate::CmpBranchCommutativeOperator for F32NeBranch {
    const NAME: &'static ::core::primitive::str = "F32NeBranch";
    type Imm = ::core::primitive::f32;
    type OpRi = crate::op::F32NeBranch_RI;
    type OpRs = crate::op::F32NeBranch_RS;
    type OpSi = crate::op::F32NeBranch_SI;
    type OpSs = crate::op::F32NeBranch_SS;
    fn make_ri(lhs: crate::Reg, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpRi {
        Self::OpRi { lhs, rhs, offset }
    }
    fn make_rs(lhs: crate::Reg, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpRs {
        Self::OpRs { lhs, rhs, offset }
    }
    fn make_si(lhs: crate::Stack, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpSi {
        Self::OpSi { lhs, rhs, offset }
    }
    fn make_ss(lhs: crate::Stack, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpSs {
        Self::OpSs { lhs, rhs, offset }
    }
}
pub enum F64NeBranch {}
impl crate::CmpBranchCommutativeOperator for F64NeBranch {
    const NAME: &'static ::core::primitive::str = "F64NeBranch";
    type Imm = ::core::primitive::f64;
    type OpRi = crate::op::F64NeBranch_RI;
    type OpRs = crate::op::F64NeBranch_RS;
    type OpSi = crate::op::F64NeBranch_SI;
    type OpSs = crate::op::F64NeBranch_SS;
    fn make_ri(lhs: crate::Reg, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpRi {
        Self::OpRi { lhs, rhs, offset }
    }
    fn make_rs(lhs: crate::Reg, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpRs {
        Self::OpRs { lhs, rhs, offset }
    }
    fn make_si(lhs: crate::Stack, rhs: Self::Imm, offset: crate::BranchOffset) -> Self::OpSi {
        Self::OpSi { lhs, rhs, offset }
    }
    fn make_ss(lhs: crate::Stack, rhs: crate::Stack, offset: crate::BranchOffset) -> Self::OpSs {
        Self::OpSs { lhs, rhs, offset }
    }
}
