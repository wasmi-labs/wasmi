// This file is automatically generated by the `build.rs` script.
//
// Do _not_ edit this file directly but change `build.rs` script logic instead.

pub enum I32Sub {}
impl crate::BinaryOperator for I32Sub {
    const NAME: &'static ::core::primitive::str = "I32Sub";
    type Imm = ::core::primitive::i32;
    type OpRir = crate::op::I32Sub_RIR;
    type OpRis = crate::op::I32Sub_RIS;
    type OpRri = crate::op::I32Sub_RRI;
    type OpRrs = crate::op::I32Sub_RRS;
    type OpRsi = crate::op::I32Sub_RSI;
    type OpRsr = crate::op::I32Sub_RSR;
    type OpRss = crate::op::I32Sub_RSS;
    fn make_rir(result: crate::Reg, lhs: Self::Imm, rhs: crate::Reg) -> Self::OpRir {
        Self::OpRir { result, lhs, rhs }
    }
    fn make_ris(result: crate::Reg, lhs: Self::Imm, rhs: crate::Stack) -> Self::OpRis {
        Self::OpRis { result, lhs, rhs }
    }
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rsr(result: crate::Reg, lhs: crate::Stack, rhs: crate::Reg) -> Self::OpRsr {
        Self::OpRsr { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
}
pub enum I64Sub {}
impl crate::BinaryOperator for I64Sub {
    const NAME: &'static ::core::primitive::str = "I64Sub";
    type Imm = ::core::primitive::i64;
    type OpRir = crate::op::I64Sub_RIR;
    type OpRis = crate::op::I64Sub_RIS;
    type OpRri = crate::op::I64Sub_RRI;
    type OpRrs = crate::op::I64Sub_RRS;
    type OpRsi = crate::op::I64Sub_RSI;
    type OpRsr = crate::op::I64Sub_RSR;
    type OpRss = crate::op::I64Sub_RSS;
    fn make_rir(result: crate::Reg, lhs: Self::Imm, rhs: crate::Reg) -> Self::OpRir {
        Self::OpRir { result, lhs, rhs }
    }
    fn make_ris(result: crate::Reg, lhs: Self::Imm, rhs: crate::Stack) -> Self::OpRis {
        Self::OpRis { result, lhs, rhs }
    }
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rsr(result: crate::Reg, lhs: crate::Stack, rhs: crate::Reg) -> Self::OpRsr {
        Self::OpRsr { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
}
pub enum I32LtS {}
impl crate::BinaryOperator for I32LtS {
    const NAME: &'static ::core::primitive::str = "I32LtS";
    type Imm = ::core::primitive::i32;
    type OpRir = crate::op::I32LtS_RIR;
    type OpRis = crate::op::I32LtS_RIS;
    type OpRri = crate::op::I32LtS_RRI;
    type OpRrs = crate::op::I32LtS_RRS;
    type OpRsi = crate::op::I32LtS_RSI;
    type OpRsr = crate::op::I32LtS_RSR;
    type OpRss = crate::op::I32LtS_RSS;
    fn make_rir(result: crate::Reg, lhs: Self::Imm, rhs: crate::Reg) -> Self::OpRir {
        Self::OpRir { result, lhs, rhs }
    }
    fn make_ris(result: crate::Reg, lhs: Self::Imm, rhs: crate::Stack) -> Self::OpRis {
        Self::OpRis { result, lhs, rhs }
    }
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rsr(result: crate::Reg, lhs: crate::Stack, rhs: crate::Reg) -> Self::OpRsr {
        Self::OpRsr { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
}
pub enum I64LtS {}
impl crate::BinaryOperator for I64LtS {
    const NAME: &'static ::core::primitive::str = "I64LtS";
    type Imm = ::core::primitive::i64;
    type OpRir = crate::op::I64LtS_RIR;
    type OpRis = crate::op::I64LtS_RIS;
    type OpRri = crate::op::I64LtS_RRI;
    type OpRrs = crate::op::I64LtS_RRS;
    type OpRsi = crate::op::I64LtS_RSI;
    type OpRsr = crate::op::I64LtS_RSR;
    type OpRss = crate::op::I64LtS_RSS;
    fn make_rir(result: crate::Reg, lhs: Self::Imm, rhs: crate::Reg) -> Self::OpRir {
        Self::OpRir { result, lhs, rhs }
    }
    fn make_ris(result: crate::Reg, lhs: Self::Imm, rhs: crate::Stack) -> Self::OpRis {
        Self::OpRis { result, lhs, rhs }
    }
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rsr(result: crate::Reg, lhs: crate::Stack, rhs: crate::Reg) -> Self::OpRsr {
        Self::OpRsr { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
}
pub enum I32LtU {}
impl crate::BinaryOperator for I32LtU {
    const NAME: &'static ::core::primitive::str = "I32LtU";
    type Imm = ::core::primitive::i32;
    type OpRir = crate::op::I32LtU_RIR;
    type OpRis = crate::op::I32LtU_RIS;
    type OpRri = crate::op::I32LtU_RRI;
    type OpRrs = crate::op::I32LtU_RRS;
    type OpRsi = crate::op::I32LtU_RSI;
    type OpRsr = crate::op::I32LtU_RSR;
    type OpRss = crate::op::I32LtU_RSS;
    fn make_rir(result: crate::Reg, lhs: Self::Imm, rhs: crate::Reg) -> Self::OpRir {
        Self::OpRir { result, lhs, rhs }
    }
    fn make_ris(result: crate::Reg, lhs: Self::Imm, rhs: crate::Stack) -> Self::OpRis {
        Self::OpRis { result, lhs, rhs }
    }
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rsr(result: crate::Reg, lhs: crate::Stack, rhs: crate::Reg) -> Self::OpRsr {
        Self::OpRsr { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
}
pub enum I64LtU {}
impl crate::BinaryOperator for I64LtU {
    const NAME: &'static ::core::primitive::str = "I64LtU";
    type Imm = ::core::primitive::i64;
    type OpRir = crate::op::I64LtU_RIR;
    type OpRis = crate::op::I64LtU_RIS;
    type OpRri = crate::op::I64LtU_RRI;
    type OpRrs = crate::op::I64LtU_RRS;
    type OpRsi = crate::op::I64LtU_RSI;
    type OpRsr = crate::op::I64LtU_RSR;
    type OpRss = crate::op::I64LtU_RSS;
    fn make_rir(result: crate::Reg, lhs: Self::Imm, rhs: crate::Reg) -> Self::OpRir {
        Self::OpRir { result, lhs, rhs }
    }
    fn make_ris(result: crate::Reg, lhs: Self::Imm, rhs: crate::Stack) -> Self::OpRis {
        Self::OpRis { result, lhs, rhs }
    }
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rsr(result: crate::Reg, lhs: crate::Stack, rhs: crate::Reg) -> Self::OpRsr {
        Self::OpRsr { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
}
pub enum I32LeS {}
impl crate::BinaryOperator for I32LeS {
    const NAME: &'static ::core::primitive::str = "I32LeS";
    type Imm = ::core::primitive::i32;
    type OpRir = crate::op::I32LeS_RIR;
    type OpRis = crate::op::I32LeS_RIS;
    type OpRri = crate::op::I32LeS_RRI;
    type OpRrs = crate::op::I32LeS_RRS;
    type OpRsi = crate::op::I32LeS_RSI;
    type OpRsr = crate::op::I32LeS_RSR;
    type OpRss = crate::op::I32LeS_RSS;
    fn make_rir(result: crate::Reg, lhs: Self::Imm, rhs: crate::Reg) -> Self::OpRir {
        Self::OpRir { result, lhs, rhs }
    }
    fn make_ris(result: crate::Reg, lhs: Self::Imm, rhs: crate::Stack) -> Self::OpRis {
        Self::OpRis { result, lhs, rhs }
    }
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rsr(result: crate::Reg, lhs: crate::Stack, rhs: crate::Reg) -> Self::OpRsr {
        Self::OpRsr { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
}
pub enum I64LeS {}
impl crate::BinaryOperator for I64LeS {
    const NAME: &'static ::core::primitive::str = "I64LeS";
    type Imm = ::core::primitive::i64;
    type OpRir = crate::op::I64LeS_RIR;
    type OpRis = crate::op::I64LeS_RIS;
    type OpRri = crate::op::I64LeS_RRI;
    type OpRrs = crate::op::I64LeS_RRS;
    type OpRsi = crate::op::I64LeS_RSI;
    type OpRsr = crate::op::I64LeS_RSR;
    type OpRss = crate::op::I64LeS_RSS;
    fn make_rir(result: crate::Reg, lhs: Self::Imm, rhs: crate::Reg) -> Self::OpRir {
        Self::OpRir { result, lhs, rhs }
    }
    fn make_ris(result: crate::Reg, lhs: Self::Imm, rhs: crate::Stack) -> Self::OpRis {
        Self::OpRis { result, lhs, rhs }
    }
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rsr(result: crate::Reg, lhs: crate::Stack, rhs: crate::Reg) -> Self::OpRsr {
        Self::OpRsr { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
}
pub enum I32LeU {}
impl crate::BinaryOperator for I32LeU {
    const NAME: &'static ::core::primitive::str = "I32LeU";
    type Imm = ::core::primitive::i32;
    type OpRir = crate::op::I32LeU_RIR;
    type OpRis = crate::op::I32LeU_RIS;
    type OpRri = crate::op::I32LeU_RRI;
    type OpRrs = crate::op::I32LeU_RRS;
    type OpRsi = crate::op::I32LeU_RSI;
    type OpRsr = crate::op::I32LeU_RSR;
    type OpRss = crate::op::I32LeU_RSS;
    fn make_rir(result: crate::Reg, lhs: Self::Imm, rhs: crate::Reg) -> Self::OpRir {
        Self::OpRir { result, lhs, rhs }
    }
    fn make_ris(result: crate::Reg, lhs: Self::Imm, rhs: crate::Stack) -> Self::OpRis {
        Self::OpRis { result, lhs, rhs }
    }
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rsr(result: crate::Reg, lhs: crate::Stack, rhs: crate::Reg) -> Self::OpRsr {
        Self::OpRsr { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
}
pub enum I64LeU {}
impl crate::BinaryOperator for I64LeU {
    const NAME: &'static ::core::primitive::str = "I64LeU";
    type Imm = ::core::primitive::i64;
    type OpRir = crate::op::I64LeU_RIR;
    type OpRis = crate::op::I64LeU_RIS;
    type OpRri = crate::op::I64LeU_RRI;
    type OpRrs = crate::op::I64LeU_RRS;
    type OpRsi = crate::op::I64LeU_RSI;
    type OpRsr = crate::op::I64LeU_RSR;
    type OpRss = crate::op::I64LeU_RSS;
    fn make_rir(result: crate::Reg, lhs: Self::Imm, rhs: crate::Reg) -> Self::OpRir {
        Self::OpRir { result, lhs, rhs }
    }
    fn make_ris(result: crate::Reg, lhs: Self::Imm, rhs: crate::Stack) -> Self::OpRis {
        Self::OpRis { result, lhs, rhs }
    }
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rsr(result: crate::Reg, lhs: crate::Stack, rhs: crate::Reg) -> Self::OpRsr {
        Self::OpRsr { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
}
pub enum I32DivS {}
impl crate::BinaryOperator for I32DivS {
    const NAME: &'static ::core::primitive::str = "I32DivS";
    type Imm = ::core::primitive::i32;
    type OpRir = crate::op::I32DivS_RIR;
    type OpRis = crate::op::I32DivS_RIS;
    type OpRri = crate::op::I32DivS_RRI;
    type OpRrs = crate::op::I32DivS_RRS;
    type OpRsi = crate::op::I32DivS_RSI;
    type OpRsr = crate::op::I32DivS_RSR;
    type OpRss = crate::op::I32DivS_RSS;
    fn make_rir(result: crate::Reg, lhs: Self::Imm, rhs: crate::Reg) -> Self::OpRir {
        Self::OpRir { result, lhs, rhs }
    }
    fn make_ris(result: crate::Reg, lhs: Self::Imm, rhs: crate::Stack) -> Self::OpRis {
        Self::OpRis { result, lhs, rhs }
    }
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rsr(result: crate::Reg, lhs: crate::Stack, rhs: crate::Reg) -> Self::OpRsr {
        Self::OpRsr { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
}
pub enum I64DivS {}
impl crate::BinaryOperator for I64DivS {
    const NAME: &'static ::core::primitive::str = "I64DivS";
    type Imm = ::core::primitive::i64;
    type OpRir = crate::op::I64DivS_RIR;
    type OpRis = crate::op::I64DivS_RIS;
    type OpRri = crate::op::I64DivS_RRI;
    type OpRrs = crate::op::I64DivS_RRS;
    type OpRsi = crate::op::I64DivS_RSI;
    type OpRsr = crate::op::I64DivS_RSR;
    type OpRss = crate::op::I64DivS_RSS;
    fn make_rir(result: crate::Reg, lhs: Self::Imm, rhs: crate::Reg) -> Self::OpRir {
        Self::OpRir { result, lhs, rhs }
    }
    fn make_ris(result: crate::Reg, lhs: Self::Imm, rhs: crate::Stack) -> Self::OpRis {
        Self::OpRis { result, lhs, rhs }
    }
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rsr(result: crate::Reg, lhs: crate::Stack, rhs: crate::Reg) -> Self::OpRsr {
        Self::OpRsr { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
}
pub enum I32DivU {}
impl crate::BinaryOperator for I32DivU {
    const NAME: &'static ::core::primitive::str = "I32DivU";
    type Imm = ::core::primitive::i32;
    type OpRir = crate::op::I32DivU_RIR;
    type OpRis = crate::op::I32DivU_RIS;
    type OpRri = crate::op::I32DivU_RRI;
    type OpRrs = crate::op::I32DivU_RRS;
    type OpRsi = crate::op::I32DivU_RSI;
    type OpRsr = crate::op::I32DivU_RSR;
    type OpRss = crate::op::I32DivU_RSS;
    fn make_rir(result: crate::Reg, lhs: Self::Imm, rhs: crate::Reg) -> Self::OpRir {
        Self::OpRir { result, lhs, rhs }
    }
    fn make_ris(result: crate::Reg, lhs: Self::Imm, rhs: crate::Stack) -> Self::OpRis {
        Self::OpRis { result, lhs, rhs }
    }
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rsr(result: crate::Reg, lhs: crate::Stack, rhs: crate::Reg) -> Self::OpRsr {
        Self::OpRsr { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
}
pub enum I64DivU {}
impl crate::BinaryOperator for I64DivU {
    const NAME: &'static ::core::primitive::str = "I64DivU";
    type Imm = ::core::primitive::i64;
    type OpRir = crate::op::I64DivU_RIR;
    type OpRis = crate::op::I64DivU_RIS;
    type OpRri = crate::op::I64DivU_RRI;
    type OpRrs = crate::op::I64DivU_RRS;
    type OpRsi = crate::op::I64DivU_RSI;
    type OpRsr = crate::op::I64DivU_RSR;
    type OpRss = crate::op::I64DivU_RSS;
    fn make_rir(result: crate::Reg, lhs: Self::Imm, rhs: crate::Reg) -> Self::OpRir {
        Self::OpRir { result, lhs, rhs }
    }
    fn make_ris(result: crate::Reg, lhs: Self::Imm, rhs: crate::Stack) -> Self::OpRis {
        Self::OpRis { result, lhs, rhs }
    }
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rsr(result: crate::Reg, lhs: crate::Stack, rhs: crate::Reg) -> Self::OpRsr {
        Self::OpRsr { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
}
pub enum I32RemS {}
impl crate::BinaryOperator for I32RemS {
    const NAME: &'static ::core::primitive::str = "I32RemS";
    type Imm = ::core::primitive::i32;
    type OpRir = crate::op::I32RemS_RIR;
    type OpRis = crate::op::I32RemS_RIS;
    type OpRri = crate::op::I32RemS_RRI;
    type OpRrs = crate::op::I32RemS_RRS;
    type OpRsi = crate::op::I32RemS_RSI;
    type OpRsr = crate::op::I32RemS_RSR;
    type OpRss = crate::op::I32RemS_RSS;
    fn make_rir(result: crate::Reg, lhs: Self::Imm, rhs: crate::Reg) -> Self::OpRir {
        Self::OpRir { result, lhs, rhs }
    }
    fn make_ris(result: crate::Reg, lhs: Self::Imm, rhs: crate::Stack) -> Self::OpRis {
        Self::OpRis { result, lhs, rhs }
    }
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rsr(result: crate::Reg, lhs: crate::Stack, rhs: crate::Reg) -> Self::OpRsr {
        Self::OpRsr { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
}
pub enum I64RemS {}
impl crate::BinaryOperator for I64RemS {
    const NAME: &'static ::core::primitive::str = "I64RemS";
    type Imm = ::core::primitive::i64;
    type OpRir = crate::op::I64RemS_RIR;
    type OpRis = crate::op::I64RemS_RIS;
    type OpRri = crate::op::I64RemS_RRI;
    type OpRrs = crate::op::I64RemS_RRS;
    type OpRsi = crate::op::I64RemS_RSI;
    type OpRsr = crate::op::I64RemS_RSR;
    type OpRss = crate::op::I64RemS_RSS;
    fn make_rir(result: crate::Reg, lhs: Self::Imm, rhs: crate::Reg) -> Self::OpRir {
        Self::OpRir { result, lhs, rhs }
    }
    fn make_ris(result: crate::Reg, lhs: Self::Imm, rhs: crate::Stack) -> Self::OpRis {
        Self::OpRis { result, lhs, rhs }
    }
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rsr(result: crate::Reg, lhs: crate::Stack, rhs: crate::Reg) -> Self::OpRsr {
        Self::OpRsr { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
}
pub enum I32RemU {}
impl crate::BinaryOperator for I32RemU {
    const NAME: &'static ::core::primitive::str = "I32RemU";
    type Imm = ::core::primitive::i32;
    type OpRir = crate::op::I32RemU_RIR;
    type OpRis = crate::op::I32RemU_RIS;
    type OpRri = crate::op::I32RemU_RRI;
    type OpRrs = crate::op::I32RemU_RRS;
    type OpRsi = crate::op::I32RemU_RSI;
    type OpRsr = crate::op::I32RemU_RSR;
    type OpRss = crate::op::I32RemU_RSS;
    fn make_rir(result: crate::Reg, lhs: Self::Imm, rhs: crate::Reg) -> Self::OpRir {
        Self::OpRir { result, lhs, rhs }
    }
    fn make_ris(result: crate::Reg, lhs: Self::Imm, rhs: crate::Stack) -> Self::OpRis {
        Self::OpRis { result, lhs, rhs }
    }
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rsr(result: crate::Reg, lhs: crate::Stack, rhs: crate::Reg) -> Self::OpRsr {
        Self::OpRsr { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
}
pub enum I64RemU {}
impl crate::BinaryOperator for I64RemU {
    const NAME: &'static ::core::primitive::str = "I64RemU";
    type Imm = ::core::primitive::i64;
    type OpRir = crate::op::I64RemU_RIR;
    type OpRis = crate::op::I64RemU_RIS;
    type OpRri = crate::op::I64RemU_RRI;
    type OpRrs = crate::op::I64RemU_RRS;
    type OpRsi = crate::op::I64RemU_RSI;
    type OpRsr = crate::op::I64RemU_RSR;
    type OpRss = crate::op::I64RemU_RSS;
    fn make_rir(result: crate::Reg, lhs: Self::Imm, rhs: crate::Reg) -> Self::OpRir {
        Self::OpRir { result, lhs, rhs }
    }
    fn make_ris(result: crate::Reg, lhs: Self::Imm, rhs: crate::Stack) -> Self::OpRis {
        Self::OpRis { result, lhs, rhs }
    }
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rsr(result: crate::Reg, lhs: crate::Stack, rhs: crate::Reg) -> Self::OpRsr {
        Self::OpRsr { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
}
pub enum I32Shl {}
impl crate::BinaryOperator for I32Shl {
    const NAME: &'static ::core::primitive::str = "I32Shl";
    type Imm = ::core::primitive::i32;
    type OpRir = crate::op::I32Shl_RIR;
    type OpRis = crate::op::I32Shl_RIS;
    type OpRri = crate::op::I32Shl_RRI;
    type OpRrs = crate::op::I32Shl_RRS;
    type OpRsi = crate::op::I32Shl_RSI;
    type OpRsr = crate::op::I32Shl_RSR;
    type OpRss = crate::op::I32Shl_RSS;
    fn make_rir(result: crate::Reg, lhs: Self::Imm, rhs: crate::Reg) -> Self::OpRir {
        Self::OpRir { result, lhs, rhs }
    }
    fn make_ris(result: crate::Reg, lhs: Self::Imm, rhs: crate::Stack) -> Self::OpRis {
        Self::OpRis { result, lhs, rhs }
    }
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rsr(result: crate::Reg, lhs: crate::Stack, rhs: crate::Reg) -> Self::OpRsr {
        Self::OpRsr { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
}
pub enum I64Shl {}
impl crate::BinaryOperator for I64Shl {
    const NAME: &'static ::core::primitive::str = "I64Shl";
    type Imm = ::core::primitive::i64;
    type OpRir = crate::op::I64Shl_RIR;
    type OpRis = crate::op::I64Shl_RIS;
    type OpRri = crate::op::I64Shl_RRI;
    type OpRrs = crate::op::I64Shl_RRS;
    type OpRsi = crate::op::I64Shl_RSI;
    type OpRsr = crate::op::I64Shl_RSR;
    type OpRss = crate::op::I64Shl_RSS;
    fn make_rir(result: crate::Reg, lhs: Self::Imm, rhs: crate::Reg) -> Self::OpRir {
        Self::OpRir { result, lhs, rhs }
    }
    fn make_ris(result: crate::Reg, lhs: Self::Imm, rhs: crate::Stack) -> Self::OpRis {
        Self::OpRis { result, lhs, rhs }
    }
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rsr(result: crate::Reg, lhs: crate::Stack, rhs: crate::Reg) -> Self::OpRsr {
        Self::OpRsr { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
}
pub enum I32ShrS {}
impl crate::BinaryOperator for I32ShrS {
    const NAME: &'static ::core::primitive::str = "I32ShrS";
    type Imm = ::core::primitive::i32;
    type OpRir = crate::op::I32ShrS_RIR;
    type OpRis = crate::op::I32ShrS_RIS;
    type OpRri = crate::op::I32ShrS_RRI;
    type OpRrs = crate::op::I32ShrS_RRS;
    type OpRsi = crate::op::I32ShrS_RSI;
    type OpRsr = crate::op::I32ShrS_RSR;
    type OpRss = crate::op::I32ShrS_RSS;
    fn make_rir(result: crate::Reg, lhs: Self::Imm, rhs: crate::Reg) -> Self::OpRir {
        Self::OpRir { result, lhs, rhs }
    }
    fn make_ris(result: crate::Reg, lhs: Self::Imm, rhs: crate::Stack) -> Self::OpRis {
        Self::OpRis { result, lhs, rhs }
    }
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rsr(result: crate::Reg, lhs: crate::Stack, rhs: crate::Reg) -> Self::OpRsr {
        Self::OpRsr { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
}
pub enum I64ShrS {}
impl crate::BinaryOperator for I64ShrS {
    const NAME: &'static ::core::primitive::str = "I64ShrS";
    type Imm = ::core::primitive::i64;
    type OpRir = crate::op::I64ShrS_RIR;
    type OpRis = crate::op::I64ShrS_RIS;
    type OpRri = crate::op::I64ShrS_RRI;
    type OpRrs = crate::op::I64ShrS_RRS;
    type OpRsi = crate::op::I64ShrS_RSI;
    type OpRsr = crate::op::I64ShrS_RSR;
    type OpRss = crate::op::I64ShrS_RSS;
    fn make_rir(result: crate::Reg, lhs: Self::Imm, rhs: crate::Reg) -> Self::OpRir {
        Self::OpRir { result, lhs, rhs }
    }
    fn make_ris(result: crate::Reg, lhs: Self::Imm, rhs: crate::Stack) -> Self::OpRis {
        Self::OpRis { result, lhs, rhs }
    }
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rsr(result: crate::Reg, lhs: crate::Stack, rhs: crate::Reg) -> Self::OpRsr {
        Self::OpRsr { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
}
pub enum I32ShrU {}
impl crate::BinaryOperator for I32ShrU {
    const NAME: &'static ::core::primitive::str = "I32ShrU";
    type Imm = ::core::primitive::i32;
    type OpRir = crate::op::I32ShrU_RIR;
    type OpRis = crate::op::I32ShrU_RIS;
    type OpRri = crate::op::I32ShrU_RRI;
    type OpRrs = crate::op::I32ShrU_RRS;
    type OpRsi = crate::op::I32ShrU_RSI;
    type OpRsr = crate::op::I32ShrU_RSR;
    type OpRss = crate::op::I32ShrU_RSS;
    fn make_rir(result: crate::Reg, lhs: Self::Imm, rhs: crate::Reg) -> Self::OpRir {
        Self::OpRir { result, lhs, rhs }
    }
    fn make_ris(result: crate::Reg, lhs: Self::Imm, rhs: crate::Stack) -> Self::OpRis {
        Self::OpRis { result, lhs, rhs }
    }
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rsr(result: crate::Reg, lhs: crate::Stack, rhs: crate::Reg) -> Self::OpRsr {
        Self::OpRsr { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
}
pub enum I64ShrU {}
impl crate::BinaryOperator for I64ShrU {
    const NAME: &'static ::core::primitive::str = "I64ShrU";
    type Imm = ::core::primitive::i64;
    type OpRir = crate::op::I64ShrU_RIR;
    type OpRis = crate::op::I64ShrU_RIS;
    type OpRri = crate::op::I64ShrU_RRI;
    type OpRrs = crate::op::I64ShrU_RRS;
    type OpRsi = crate::op::I64ShrU_RSI;
    type OpRsr = crate::op::I64ShrU_RSR;
    type OpRss = crate::op::I64ShrU_RSS;
    fn make_rir(result: crate::Reg, lhs: Self::Imm, rhs: crate::Reg) -> Self::OpRir {
        Self::OpRir { result, lhs, rhs }
    }
    fn make_ris(result: crate::Reg, lhs: Self::Imm, rhs: crate::Stack) -> Self::OpRis {
        Self::OpRis { result, lhs, rhs }
    }
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rsr(result: crate::Reg, lhs: crate::Stack, rhs: crate::Reg) -> Self::OpRsr {
        Self::OpRsr { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
}
pub enum I32Rotl {}
impl crate::BinaryOperator for I32Rotl {
    const NAME: &'static ::core::primitive::str = "I32Rotl";
    type Imm = ::core::primitive::i32;
    type OpRir = crate::op::I32Rotl_RIR;
    type OpRis = crate::op::I32Rotl_RIS;
    type OpRri = crate::op::I32Rotl_RRI;
    type OpRrs = crate::op::I32Rotl_RRS;
    type OpRsi = crate::op::I32Rotl_RSI;
    type OpRsr = crate::op::I32Rotl_RSR;
    type OpRss = crate::op::I32Rotl_RSS;
    fn make_rir(result: crate::Reg, lhs: Self::Imm, rhs: crate::Reg) -> Self::OpRir {
        Self::OpRir { result, lhs, rhs }
    }
    fn make_ris(result: crate::Reg, lhs: Self::Imm, rhs: crate::Stack) -> Self::OpRis {
        Self::OpRis { result, lhs, rhs }
    }
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rsr(result: crate::Reg, lhs: crate::Stack, rhs: crate::Reg) -> Self::OpRsr {
        Self::OpRsr { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
}
pub enum I64Rotl {}
impl crate::BinaryOperator for I64Rotl {
    const NAME: &'static ::core::primitive::str = "I64Rotl";
    type Imm = ::core::primitive::i64;
    type OpRir = crate::op::I64Rotl_RIR;
    type OpRis = crate::op::I64Rotl_RIS;
    type OpRri = crate::op::I64Rotl_RRI;
    type OpRrs = crate::op::I64Rotl_RRS;
    type OpRsi = crate::op::I64Rotl_RSI;
    type OpRsr = crate::op::I64Rotl_RSR;
    type OpRss = crate::op::I64Rotl_RSS;
    fn make_rir(result: crate::Reg, lhs: Self::Imm, rhs: crate::Reg) -> Self::OpRir {
        Self::OpRir { result, lhs, rhs }
    }
    fn make_ris(result: crate::Reg, lhs: Self::Imm, rhs: crate::Stack) -> Self::OpRis {
        Self::OpRis { result, lhs, rhs }
    }
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rsr(result: crate::Reg, lhs: crate::Stack, rhs: crate::Reg) -> Self::OpRsr {
        Self::OpRsr { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
}
pub enum I32Rotr {}
impl crate::BinaryOperator for I32Rotr {
    const NAME: &'static ::core::primitive::str = "I32Rotr";
    type Imm = ::core::primitive::i32;
    type OpRir = crate::op::I32Rotr_RIR;
    type OpRis = crate::op::I32Rotr_RIS;
    type OpRri = crate::op::I32Rotr_RRI;
    type OpRrs = crate::op::I32Rotr_RRS;
    type OpRsi = crate::op::I32Rotr_RSI;
    type OpRsr = crate::op::I32Rotr_RSR;
    type OpRss = crate::op::I32Rotr_RSS;
    fn make_rir(result: crate::Reg, lhs: Self::Imm, rhs: crate::Reg) -> Self::OpRir {
        Self::OpRir { result, lhs, rhs }
    }
    fn make_ris(result: crate::Reg, lhs: Self::Imm, rhs: crate::Stack) -> Self::OpRis {
        Self::OpRis { result, lhs, rhs }
    }
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rsr(result: crate::Reg, lhs: crate::Stack, rhs: crate::Reg) -> Self::OpRsr {
        Self::OpRsr { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
}
pub enum I64Rotr {}
impl crate::BinaryOperator for I64Rotr {
    const NAME: &'static ::core::primitive::str = "I64Rotr";
    type Imm = ::core::primitive::i64;
    type OpRir = crate::op::I64Rotr_RIR;
    type OpRis = crate::op::I64Rotr_RIS;
    type OpRri = crate::op::I64Rotr_RRI;
    type OpRrs = crate::op::I64Rotr_RRS;
    type OpRsi = crate::op::I64Rotr_RSI;
    type OpRsr = crate::op::I64Rotr_RSR;
    type OpRss = crate::op::I64Rotr_RSS;
    fn make_rir(result: crate::Reg, lhs: Self::Imm, rhs: crate::Reg) -> Self::OpRir {
        Self::OpRir { result, lhs, rhs }
    }
    fn make_ris(result: crate::Reg, lhs: Self::Imm, rhs: crate::Stack) -> Self::OpRis {
        Self::OpRis { result, lhs, rhs }
    }
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rsr(result: crate::Reg, lhs: crate::Stack, rhs: crate::Reg) -> Self::OpRsr {
        Self::OpRsr { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
}
pub enum F32Sub {}
impl crate::BinaryOperator for F32Sub {
    const NAME: &'static ::core::primitive::str = "F32Sub";
    type Imm = ::core::primitive::f32;
    type OpRir = crate::op::F32Sub_RIR;
    type OpRis = crate::op::F32Sub_RIS;
    type OpRri = crate::op::F32Sub_RRI;
    type OpRrs = crate::op::F32Sub_RRS;
    type OpRsi = crate::op::F32Sub_RSI;
    type OpRsr = crate::op::F32Sub_RSR;
    type OpRss = crate::op::F32Sub_RSS;
    fn make_rir(result: crate::Reg, lhs: Self::Imm, rhs: crate::Reg) -> Self::OpRir {
        Self::OpRir { result, lhs, rhs }
    }
    fn make_ris(result: crate::Reg, lhs: Self::Imm, rhs: crate::Stack) -> Self::OpRis {
        Self::OpRis { result, lhs, rhs }
    }
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rsr(result: crate::Reg, lhs: crate::Stack, rhs: crate::Reg) -> Self::OpRsr {
        Self::OpRsr { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
}
pub enum F64Sub {}
impl crate::BinaryOperator for F64Sub {
    const NAME: &'static ::core::primitive::str = "F64Sub";
    type Imm = ::core::primitive::f64;
    type OpRir = crate::op::F64Sub_RIR;
    type OpRis = crate::op::F64Sub_RIS;
    type OpRri = crate::op::F64Sub_RRI;
    type OpRrs = crate::op::F64Sub_RRS;
    type OpRsi = crate::op::F64Sub_RSI;
    type OpRsr = crate::op::F64Sub_RSR;
    type OpRss = crate::op::F64Sub_RSS;
    fn make_rir(result: crate::Reg, lhs: Self::Imm, rhs: crate::Reg) -> Self::OpRir {
        Self::OpRir { result, lhs, rhs }
    }
    fn make_ris(result: crate::Reg, lhs: Self::Imm, rhs: crate::Stack) -> Self::OpRis {
        Self::OpRis { result, lhs, rhs }
    }
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rsr(result: crate::Reg, lhs: crate::Stack, rhs: crate::Reg) -> Self::OpRsr {
        Self::OpRsr { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
}
pub enum F32Div {}
impl crate::BinaryOperator for F32Div {
    const NAME: &'static ::core::primitive::str = "F32Div";
    type Imm = ::core::primitive::f32;
    type OpRir = crate::op::F32Div_RIR;
    type OpRis = crate::op::F32Div_RIS;
    type OpRri = crate::op::F32Div_RRI;
    type OpRrs = crate::op::F32Div_RRS;
    type OpRsi = crate::op::F32Div_RSI;
    type OpRsr = crate::op::F32Div_RSR;
    type OpRss = crate::op::F32Div_RSS;
    fn make_rir(result: crate::Reg, lhs: Self::Imm, rhs: crate::Reg) -> Self::OpRir {
        Self::OpRir { result, lhs, rhs }
    }
    fn make_ris(result: crate::Reg, lhs: Self::Imm, rhs: crate::Stack) -> Self::OpRis {
        Self::OpRis { result, lhs, rhs }
    }
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rsr(result: crate::Reg, lhs: crate::Stack, rhs: crate::Reg) -> Self::OpRsr {
        Self::OpRsr { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
}
pub enum F64Div {}
impl crate::BinaryOperator for F64Div {
    const NAME: &'static ::core::primitive::str = "F64Div";
    type Imm = ::core::primitive::f64;
    type OpRir = crate::op::F64Div_RIR;
    type OpRis = crate::op::F64Div_RIS;
    type OpRri = crate::op::F64Div_RRI;
    type OpRrs = crate::op::F64Div_RRS;
    type OpRsi = crate::op::F64Div_RSI;
    type OpRsr = crate::op::F64Div_RSR;
    type OpRss = crate::op::F64Div_RSS;
    fn make_rir(result: crate::Reg, lhs: Self::Imm, rhs: crate::Reg) -> Self::OpRir {
        Self::OpRir { result, lhs, rhs }
    }
    fn make_ris(result: crate::Reg, lhs: Self::Imm, rhs: crate::Stack) -> Self::OpRis {
        Self::OpRis { result, lhs, rhs }
    }
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rsr(result: crate::Reg, lhs: crate::Stack, rhs: crate::Reg) -> Self::OpRsr {
        Self::OpRsr { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
}
pub enum F32Copysign {}
impl crate::BinaryOperator for F32Copysign {
    const NAME: &'static ::core::primitive::str = "F32Copysign";
    type Imm = ::core::primitive::f32;
    type OpRir = crate::op::F32Copysign_RIR;
    type OpRis = crate::op::F32Copysign_RIS;
    type OpRri = crate::op::F32Copysign_RRI;
    type OpRrs = crate::op::F32Copysign_RRS;
    type OpRsi = crate::op::F32Copysign_RSI;
    type OpRsr = crate::op::F32Copysign_RSR;
    type OpRss = crate::op::F32Copysign_RSS;
    fn make_rir(result: crate::Reg, lhs: Self::Imm, rhs: crate::Reg) -> Self::OpRir {
        Self::OpRir { result, lhs, rhs }
    }
    fn make_ris(result: crate::Reg, lhs: Self::Imm, rhs: crate::Stack) -> Self::OpRis {
        Self::OpRis { result, lhs, rhs }
    }
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rsr(result: crate::Reg, lhs: crate::Stack, rhs: crate::Reg) -> Self::OpRsr {
        Self::OpRsr { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
}
pub enum F64Copysign {}
impl crate::BinaryOperator for F64Copysign {
    const NAME: &'static ::core::primitive::str = "F64Copysign";
    type Imm = ::core::primitive::f64;
    type OpRir = crate::op::F64Copysign_RIR;
    type OpRis = crate::op::F64Copysign_RIS;
    type OpRri = crate::op::F64Copysign_RRI;
    type OpRrs = crate::op::F64Copysign_RRS;
    type OpRsi = crate::op::F64Copysign_RSI;
    type OpRsr = crate::op::F64Copysign_RSR;
    type OpRss = crate::op::F64Copysign_RSS;
    fn make_rir(result: crate::Reg, lhs: Self::Imm, rhs: crate::Reg) -> Self::OpRir {
        Self::OpRir { result, lhs, rhs }
    }
    fn make_ris(result: crate::Reg, lhs: Self::Imm, rhs: crate::Stack) -> Self::OpRis {
        Self::OpRis { result, lhs, rhs }
    }
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rsr(result: crate::Reg, lhs: crate::Stack, rhs: crate::Reg) -> Self::OpRsr {
        Self::OpRsr { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
}
