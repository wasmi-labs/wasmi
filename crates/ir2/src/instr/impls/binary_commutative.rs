// This file is automatically generated by the `build.rs` script.
//
// Do _not_ edit this file directly but change `build.rs` script logic instead.

pub enum I32Add {}
impl crate::BinaryCommutativeOperator for I32Add {
    const NAME: &'static ::core::primitive::str = "I32Add";
    type Imm = ::core::primitive::i32;
    type OpRri = crate::op::I32Add_RRI;
    type OpRrs = crate::op::I32Add_RRS;
    type OpRsi = crate::op::I32Add_RSI;
    type OpRss = crate::op::I32Add_RSS;
    type OpSri = crate::op::I32Add_SRI;
    type OpSrs = crate::op::I32Add_SRS;
    type OpSsi = crate::op::I32Add_SSI;
    type OpSss = crate::op::I32Add_SSS;
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
    fn make_sri(result: crate::Stack, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpSri {
        Self::OpSri { result, lhs, rhs }
    }
    fn make_srs(result: crate::Stack, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpSrs {
        Self::OpSrs { result, lhs, rhs }
    }
    fn make_ssi(result: crate::Stack, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpSsi {
        Self::OpSsi { result, lhs, rhs }
    }
    fn make_sss(result: crate::Stack, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpSss {
        Self::OpSss { result, lhs, rhs }
    }
}
pub enum I64Add {}
impl crate::BinaryCommutativeOperator for I64Add {
    const NAME: &'static ::core::primitive::str = "I64Add";
    type Imm = ::core::primitive::i64;
    type OpRri = crate::op::I64Add_RRI;
    type OpRrs = crate::op::I64Add_RRS;
    type OpRsi = crate::op::I64Add_RSI;
    type OpRss = crate::op::I64Add_RSS;
    type OpSri = crate::op::I64Add_SRI;
    type OpSrs = crate::op::I64Add_SRS;
    type OpSsi = crate::op::I64Add_SSI;
    type OpSss = crate::op::I64Add_SSS;
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
    fn make_sri(result: crate::Stack, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpSri {
        Self::OpSri { result, lhs, rhs }
    }
    fn make_srs(result: crate::Stack, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpSrs {
        Self::OpSrs { result, lhs, rhs }
    }
    fn make_ssi(result: crate::Stack, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpSsi {
        Self::OpSsi { result, lhs, rhs }
    }
    fn make_sss(result: crate::Stack, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpSss {
        Self::OpSss { result, lhs, rhs }
    }
}
pub enum I32Mul {}
impl crate::BinaryCommutativeOperator for I32Mul {
    const NAME: &'static ::core::primitive::str = "I32Mul";
    type Imm = ::core::primitive::i32;
    type OpRri = crate::op::I32Mul_RRI;
    type OpRrs = crate::op::I32Mul_RRS;
    type OpRsi = crate::op::I32Mul_RSI;
    type OpRss = crate::op::I32Mul_RSS;
    type OpSri = crate::op::I32Mul_SRI;
    type OpSrs = crate::op::I32Mul_SRS;
    type OpSsi = crate::op::I32Mul_SSI;
    type OpSss = crate::op::I32Mul_SSS;
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
    fn make_sri(result: crate::Stack, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpSri {
        Self::OpSri { result, lhs, rhs }
    }
    fn make_srs(result: crate::Stack, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpSrs {
        Self::OpSrs { result, lhs, rhs }
    }
    fn make_ssi(result: crate::Stack, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpSsi {
        Self::OpSsi { result, lhs, rhs }
    }
    fn make_sss(result: crate::Stack, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpSss {
        Self::OpSss { result, lhs, rhs }
    }
}
pub enum I64Mul {}
impl crate::BinaryCommutativeOperator for I64Mul {
    const NAME: &'static ::core::primitive::str = "I64Mul";
    type Imm = ::core::primitive::i64;
    type OpRri = crate::op::I64Mul_RRI;
    type OpRrs = crate::op::I64Mul_RRS;
    type OpRsi = crate::op::I64Mul_RSI;
    type OpRss = crate::op::I64Mul_RSS;
    type OpSri = crate::op::I64Mul_SRI;
    type OpSrs = crate::op::I64Mul_SRS;
    type OpSsi = crate::op::I64Mul_SSI;
    type OpSss = crate::op::I64Mul_SSS;
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
    fn make_sri(result: crate::Stack, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpSri {
        Self::OpSri { result, lhs, rhs }
    }
    fn make_srs(result: crate::Stack, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpSrs {
        Self::OpSrs { result, lhs, rhs }
    }
    fn make_ssi(result: crate::Stack, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpSsi {
        Self::OpSsi { result, lhs, rhs }
    }
    fn make_sss(result: crate::Stack, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpSss {
        Self::OpSss { result, lhs, rhs }
    }
}
pub enum I32And {}
impl crate::BinaryCommutativeOperator for I32And {
    const NAME: &'static ::core::primitive::str = "I32And";
    type Imm = ::core::primitive::i32;
    type OpRri = crate::op::I32And_RRI;
    type OpRrs = crate::op::I32And_RRS;
    type OpRsi = crate::op::I32And_RSI;
    type OpRss = crate::op::I32And_RSS;
    type OpSri = crate::op::I32And_SRI;
    type OpSrs = crate::op::I32And_SRS;
    type OpSsi = crate::op::I32And_SSI;
    type OpSss = crate::op::I32And_SSS;
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
    fn make_sri(result: crate::Stack, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpSri {
        Self::OpSri { result, lhs, rhs }
    }
    fn make_srs(result: crate::Stack, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpSrs {
        Self::OpSrs { result, lhs, rhs }
    }
    fn make_ssi(result: crate::Stack, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpSsi {
        Self::OpSsi { result, lhs, rhs }
    }
    fn make_sss(result: crate::Stack, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpSss {
        Self::OpSss { result, lhs, rhs }
    }
}
pub enum I64And {}
impl crate::BinaryCommutativeOperator for I64And {
    const NAME: &'static ::core::primitive::str = "I64And";
    type Imm = ::core::primitive::i64;
    type OpRri = crate::op::I64And_RRI;
    type OpRrs = crate::op::I64And_RRS;
    type OpRsi = crate::op::I64And_RSI;
    type OpRss = crate::op::I64And_RSS;
    type OpSri = crate::op::I64And_SRI;
    type OpSrs = crate::op::I64And_SRS;
    type OpSsi = crate::op::I64And_SSI;
    type OpSss = crate::op::I64And_SSS;
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
    fn make_sri(result: crate::Stack, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpSri {
        Self::OpSri { result, lhs, rhs }
    }
    fn make_srs(result: crate::Stack, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpSrs {
        Self::OpSrs { result, lhs, rhs }
    }
    fn make_ssi(result: crate::Stack, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpSsi {
        Self::OpSsi { result, lhs, rhs }
    }
    fn make_sss(result: crate::Stack, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpSss {
        Self::OpSss { result, lhs, rhs }
    }
}
pub enum I32Or {}
impl crate::BinaryCommutativeOperator for I32Or {
    const NAME: &'static ::core::primitive::str = "I32Or";
    type Imm = ::core::primitive::i32;
    type OpRri = crate::op::I32Or_RRI;
    type OpRrs = crate::op::I32Or_RRS;
    type OpRsi = crate::op::I32Or_RSI;
    type OpRss = crate::op::I32Or_RSS;
    type OpSri = crate::op::I32Or_SRI;
    type OpSrs = crate::op::I32Or_SRS;
    type OpSsi = crate::op::I32Or_SSI;
    type OpSss = crate::op::I32Or_SSS;
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
    fn make_sri(result: crate::Stack, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpSri {
        Self::OpSri { result, lhs, rhs }
    }
    fn make_srs(result: crate::Stack, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpSrs {
        Self::OpSrs { result, lhs, rhs }
    }
    fn make_ssi(result: crate::Stack, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpSsi {
        Self::OpSsi { result, lhs, rhs }
    }
    fn make_sss(result: crate::Stack, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpSss {
        Self::OpSss { result, lhs, rhs }
    }
}
pub enum I64Or {}
impl crate::BinaryCommutativeOperator for I64Or {
    const NAME: &'static ::core::primitive::str = "I64Or";
    type Imm = ::core::primitive::i64;
    type OpRri = crate::op::I64Or_RRI;
    type OpRrs = crate::op::I64Or_RRS;
    type OpRsi = crate::op::I64Or_RSI;
    type OpRss = crate::op::I64Or_RSS;
    type OpSri = crate::op::I64Or_SRI;
    type OpSrs = crate::op::I64Or_SRS;
    type OpSsi = crate::op::I64Or_SSI;
    type OpSss = crate::op::I64Or_SSS;
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
    fn make_sri(result: crate::Stack, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpSri {
        Self::OpSri { result, lhs, rhs }
    }
    fn make_srs(result: crate::Stack, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpSrs {
        Self::OpSrs { result, lhs, rhs }
    }
    fn make_ssi(result: crate::Stack, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpSsi {
        Self::OpSsi { result, lhs, rhs }
    }
    fn make_sss(result: crate::Stack, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpSss {
        Self::OpSss { result, lhs, rhs }
    }
}
pub enum I32Xor {}
impl crate::BinaryCommutativeOperator for I32Xor {
    const NAME: &'static ::core::primitive::str = "I32Xor";
    type Imm = ::core::primitive::i32;
    type OpRri = crate::op::I32Xor_RRI;
    type OpRrs = crate::op::I32Xor_RRS;
    type OpRsi = crate::op::I32Xor_RSI;
    type OpRss = crate::op::I32Xor_RSS;
    type OpSri = crate::op::I32Xor_SRI;
    type OpSrs = crate::op::I32Xor_SRS;
    type OpSsi = crate::op::I32Xor_SSI;
    type OpSss = crate::op::I32Xor_SSS;
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
    fn make_sri(result: crate::Stack, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpSri {
        Self::OpSri { result, lhs, rhs }
    }
    fn make_srs(result: crate::Stack, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpSrs {
        Self::OpSrs { result, lhs, rhs }
    }
    fn make_ssi(result: crate::Stack, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpSsi {
        Self::OpSsi { result, lhs, rhs }
    }
    fn make_sss(result: crate::Stack, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpSss {
        Self::OpSss { result, lhs, rhs }
    }
}
pub enum I64Xor {}
impl crate::BinaryCommutativeOperator for I64Xor {
    const NAME: &'static ::core::primitive::str = "I64Xor";
    type Imm = ::core::primitive::i64;
    type OpRri = crate::op::I64Xor_RRI;
    type OpRrs = crate::op::I64Xor_RRS;
    type OpRsi = crate::op::I64Xor_RSI;
    type OpRss = crate::op::I64Xor_RSS;
    type OpSri = crate::op::I64Xor_SRI;
    type OpSrs = crate::op::I64Xor_SRS;
    type OpSsi = crate::op::I64Xor_SSI;
    type OpSss = crate::op::I64Xor_SSS;
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
    fn make_sri(result: crate::Stack, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpSri {
        Self::OpSri { result, lhs, rhs }
    }
    fn make_srs(result: crate::Stack, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpSrs {
        Self::OpSrs { result, lhs, rhs }
    }
    fn make_ssi(result: crate::Stack, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpSsi {
        Self::OpSsi { result, lhs, rhs }
    }
    fn make_sss(result: crate::Stack, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpSss {
        Self::OpSss { result, lhs, rhs }
    }
}
pub enum I32Eq {}
impl crate::BinaryCommutativeOperator for I32Eq {
    const NAME: &'static ::core::primitive::str = "I32Eq";
    type Imm = ::core::primitive::i32;
    type OpRri = crate::op::I32Eq_RRI;
    type OpRrs = crate::op::I32Eq_RRS;
    type OpRsi = crate::op::I32Eq_RSI;
    type OpRss = crate::op::I32Eq_RSS;
    type OpSri = crate::op::I32Eq_SRI;
    type OpSrs = crate::op::I32Eq_SRS;
    type OpSsi = crate::op::I32Eq_SSI;
    type OpSss = crate::op::I32Eq_SSS;
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
    fn make_sri(result: crate::Stack, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpSri {
        Self::OpSri { result, lhs, rhs }
    }
    fn make_srs(result: crate::Stack, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpSrs {
        Self::OpSrs { result, lhs, rhs }
    }
    fn make_ssi(result: crate::Stack, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpSsi {
        Self::OpSsi { result, lhs, rhs }
    }
    fn make_sss(result: crate::Stack, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpSss {
        Self::OpSss { result, lhs, rhs }
    }
}
pub enum I64Eq {}
impl crate::BinaryCommutativeOperator for I64Eq {
    const NAME: &'static ::core::primitive::str = "I64Eq";
    type Imm = ::core::primitive::i64;
    type OpRri = crate::op::I64Eq_RRI;
    type OpRrs = crate::op::I64Eq_RRS;
    type OpRsi = crate::op::I64Eq_RSI;
    type OpRss = crate::op::I64Eq_RSS;
    type OpSri = crate::op::I64Eq_SRI;
    type OpSrs = crate::op::I64Eq_SRS;
    type OpSsi = crate::op::I64Eq_SSI;
    type OpSss = crate::op::I64Eq_SSS;
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
    fn make_sri(result: crate::Stack, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpSri {
        Self::OpSri { result, lhs, rhs }
    }
    fn make_srs(result: crate::Stack, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpSrs {
        Self::OpSrs { result, lhs, rhs }
    }
    fn make_ssi(result: crate::Stack, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpSsi {
        Self::OpSsi { result, lhs, rhs }
    }
    fn make_sss(result: crate::Stack, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpSss {
        Self::OpSss { result, lhs, rhs }
    }
}
pub enum I32Ne {}
impl crate::BinaryCommutativeOperator for I32Ne {
    const NAME: &'static ::core::primitive::str = "I32Ne";
    type Imm = ::core::primitive::i32;
    type OpRri = crate::op::I32Ne_RRI;
    type OpRrs = crate::op::I32Ne_RRS;
    type OpRsi = crate::op::I32Ne_RSI;
    type OpRss = crate::op::I32Ne_RSS;
    type OpSri = crate::op::I32Ne_SRI;
    type OpSrs = crate::op::I32Ne_SRS;
    type OpSsi = crate::op::I32Ne_SSI;
    type OpSss = crate::op::I32Ne_SSS;
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
    fn make_sri(result: crate::Stack, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpSri {
        Self::OpSri { result, lhs, rhs }
    }
    fn make_srs(result: crate::Stack, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpSrs {
        Self::OpSrs { result, lhs, rhs }
    }
    fn make_ssi(result: crate::Stack, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpSsi {
        Self::OpSsi { result, lhs, rhs }
    }
    fn make_sss(result: crate::Stack, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpSss {
        Self::OpSss { result, lhs, rhs }
    }
}
pub enum I64Ne {}
impl crate::BinaryCommutativeOperator for I64Ne {
    const NAME: &'static ::core::primitive::str = "I64Ne";
    type Imm = ::core::primitive::i64;
    type OpRri = crate::op::I64Ne_RRI;
    type OpRrs = crate::op::I64Ne_RRS;
    type OpRsi = crate::op::I64Ne_RSI;
    type OpRss = crate::op::I64Ne_RSS;
    type OpSri = crate::op::I64Ne_SRI;
    type OpSrs = crate::op::I64Ne_SRS;
    type OpSsi = crate::op::I64Ne_SSI;
    type OpSss = crate::op::I64Ne_SSS;
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
    fn make_sri(result: crate::Stack, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpSri {
        Self::OpSri { result, lhs, rhs }
    }
    fn make_srs(result: crate::Stack, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpSrs {
        Self::OpSrs { result, lhs, rhs }
    }
    fn make_ssi(result: crate::Stack, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpSsi {
        Self::OpSsi { result, lhs, rhs }
    }
    fn make_sss(result: crate::Stack, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpSss {
        Self::OpSss { result, lhs, rhs }
    }
}
pub enum F32Add {}
impl crate::BinaryCommutativeOperator for F32Add {
    const NAME: &'static ::core::primitive::str = "F32Add";
    type Imm = ::core::primitive::f32;
    type OpRri = crate::op::F32Add_RRI;
    type OpRrs = crate::op::F32Add_RRS;
    type OpRsi = crate::op::F32Add_RSI;
    type OpRss = crate::op::F32Add_RSS;
    type OpSri = crate::op::F32Add_SRI;
    type OpSrs = crate::op::F32Add_SRS;
    type OpSsi = crate::op::F32Add_SSI;
    type OpSss = crate::op::F32Add_SSS;
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
    fn make_sri(result: crate::Stack, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpSri {
        Self::OpSri { result, lhs, rhs }
    }
    fn make_srs(result: crate::Stack, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpSrs {
        Self::OpSrs { result, lhs, rhs }
    }
    fn make_ssi(result: crate::Stack, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpSsi {
        Self::OpSsi { result, lhs, rhs }
    }
    fn make_sss(result: crate::Stack, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpSss {
        Self::OpSss { result, lhs, rhs }
    }
}
pub enum F64Add {}
impl crate::BinaryCommutativeOperator for F64Add {
    const NAME: &'static ::core::primitive::str = "F64Add";
    type Imm = ::core::primitive::f64;
    type OpRri = crate::op::F64Add_RRI;
    type OpRrs = crate::op::F64Add_RRS;
    type OpRsi = crate::op::F64Add_RSI;
    type OpRss = crate::op::F64Add_RSS;
    type OpSri = crate::op::F64Add_SRI;
    type OpSrs = crate::op::F64Add_SRS;
    type OpSsi = crate::op::F64Add_SSI;
    type OpSss = crate::op::F64Add_SSS;
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
    fn make_sri(result: crate::Stack, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpSri {
        Self::OpSri { result, lhs, rhs }
    }
    fn make_srs(result: crate::Stack, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpSrs {
        Self::OpSrs { result, lhs, rhs }
    }
    fn make_ssi(result: crate::Stack, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpSsi {
        Self::OpSsi { result, lhs, rhs }
    }
    fn make_sss(result: crate::Stack, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpSss {
        Self::OpSss { result, lhs, rhs }
    }
}
pub enum F32Mul {}
impl crate::BinaryCommutativeOperator for F32Mul {
    const NAME: &'static ::core::primitive::str = "F32Mul";
    type Imm = ::core::primitive::f32;
    type OpRri = crate::op::F32Mul_RRI;
    type OpRrs = crate::op::F32Mul_RRS;
    type OpRsi = crate::op::F32Mul_RSI;
    type OpRss = crate::op::F32Mul_RSS;
    type OpSri = crate::op::F32Mul_SRI;
    type OpSrs = crate::op::F32Mul_SRS;
    type OpSsi = crate::op::F32Mul_SSI;
    type OpSss = crate::op::F32Mul_SSS;
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
    fn make_sri(result: crate::Stack, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpSri {
        Self::OpSri { result, lhs, rhs }
    }
    fn make_srs(result: crate::Stack, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpSrs {
        Self::OpSrs { result, lhs, rhs }
    }
    fn make_ssi(result: crate::Stack, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpSsi {
        Self::OpSsi { result, lhs, rhs }
    }
    fn make_sss(result: crate::Stack, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpSss {
        Self::OpSss { result, lhs, rhs }
    }
}
pub enum F64Mul {}
impl crate::BinaryCommutativeOperator for F64Mul {
    const NAME: &'static ::core::primitive::str = "F64Mul";
    type Imm = ::core::primitive::f64;
    type OpRri = crate::op::F64Mul_RRI;
    type OpRrs = crate::op::F64Mul_RRS;
    type OpRsi = crate::op::F64Mul_RSI;
    type OpRss = crate::op::F64Mul_RSS;
    type OpSri = crate::op::F64Mul_SRI;
    type OpSrs = crate::op::F64Mul_SRS;
    type OpSsi = crate::op::F64Mul_SSI;
    type OpSss = crate::op::F64Mul_SSS;
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
    fn make_sri(result: crate::Stack, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpSri {
        Self::OpSri { result, lhs, rhs }
    }
    fn make_srs(result: crate::Stack, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpSrs {
        Self::OpSrs { result, lhs, rhs }
    }
    fn make_ssi(result: crate::Stack, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpSsi {
        Self::OpSsi { result, lhs, rhs }
    }
    fn make_sss(result: crate::Stack, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpSss {
        Self::OpSss { result, lhs, rhs }
    }
}
pub enum F32Eq {}
impl crate::BinaryCommutativeOperator for F32Eq {
    const NAME: &'static ::core::primitive::str = "F32Eq";
    type Imm = ::core::primitive::f32;
    type OpRri = crate::op::F32Eq_RRI;
    type OpRrs = crate::op::F32Eq_RRS;
    type OpRsi = crate::op::F32Eq_RSI;
    type OpRss = crate::op::F32Eq_RSS;
    type OpSri = crate::op::F32Eq_SRI;
    type OpSrs = crate::op::F32Eq_SRS;
    type OpSsi = crate::op::F32Eq_SSI;
    type OpSss = crate::op::F32Eq_SSS;
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
    fn make_sri(result: crate::Stack, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpSri {
        Self::OpSri { result, lhs, rhs }
    }
    fn make_srs(result: crate::Stack, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpSrs {
        Self::OpSrs { result, lhs, rhs }
    }
    fn make_ssi(result: crate::Stack, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpSsi {
        Self::OpSsi { result, lhs, rhs }
    }
    fn make_sss(result: crate::Stack, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpSss {
        Self::OpSss { result, lhs, rhs }
    }
}
pub enum F64Eq {}
impl crate::BinaryCommutativeOperator for F64Eq {
    const NAME: &'static ::core::primitive::str = "F64Eq";
    type Imm = ::core::primitive::f64;
    type OpRri = crate::op::F64Eq_RRI;
    type OpRrs = crate::op::F64Eq_RRS;
    type OpRsi = crate::op::F64Eq_RSI;
    type OpRss = crate::op::F64Eq_RSS;
    type OpSri = crate::op::F64Eq_SRI;
    type OpSrs = crate::op::F64Eq_SRS;
    type OpSsi = crate::op::F64Eq_SSI;
    type OpSss = crate::op::F64Eq_SSS;
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
    fn make_sri(result: crate::Stack, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpSri {
        Self::OpSri { result, lhs, rhs }
    }
    fn make_srs(result: crate::Stack, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpSrs {
        Self::OpSrs { result, lhs, rhs }
    }
    fn make_ssi(result: crate::Stack, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpSsi {
        Self::OpSsi { result, lhs, rhs }
    }
    fn make_sss(result: crate::Stack, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpSss {
        Self::OpSss { result, lhs, rhs }
    }
}
pub enum F32Ne {}
impl crate::BinaryCommutativeOperator for F32Ne {
    const NAME: &'static ::core::primitive::str = "F32Ne";
    type Imm = ::core::primitive::f32;
    type OpRri = crate::op::F32Ne_RRI;
    type OpRrs = crate::op::F32Ne_RRS;
    type OpRsi = crate::op::F32Ne_RSI;
    type OpRss = crate::op::F32Ne_RSS;
    type OpSri = crate::op::F32Ne_SRI;
    type OpSrs = crate::op::F32Ne_SRS;
    type OpSsi = crate::op::F32Ne_SSI;
    type OpSss = crate::op::F32Ne_SSS;
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
    fn make_sri(result: crate::Stack, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpSri {
        Self::OpSri { result, lhs, rhs }
    }
    fn make_srs(result: crate::Stack, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpSrs {
        Self::OpSrs { result, lhs, rhs }
    }
    fn make_ssi(result: crate::Stack, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpSsi {
        Self::OpSsi { result, lhs, rhs }
    }
    fn make_sss(result: crate::Stack, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpSss {
        Self::OpSss { result, lhs, rhs }
    }
}
pub enum F64Ne {}
impl crate::BinaryCommutativeOperator for F64Ne {
    const NAME: &'static ::core::primitive::str = "F64Ne";
    type Imm = ::core::primitive::f64;
    type OpRri = crate::op::F64Ne_RRI;
    type OpRrs = crate::op::F64Ne_RRS;
    type OpRsi = crate::op::F64Ne_RSI;
    type OpRss = crate::op::F64Ne_RSS;
    type OpSri = crate::op::F64Ne_SRI;
    type OpSrs = crate::op::F64Ne_SRS;
    type OpSsi = crate::op::F64Ne_SSI;
    type OpSss = crate::op::F64Ne_SSS;
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
    fn make_sri(result: crate::Stack, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpSri {
        Self::OpSri { result, lhs, rhs }
    }
    fn make_srs(result: crate::Stack, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpSrs {
        Self::OpSrs { result, lhs, rhs }
    }
    fn make_ssi(result: crate::Stack, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpSsi {
        Self::OpSsi { result, lhs, rhs }
    }
    fn make_sss(result: crate::Stack, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpSss {
        Self::OpSss { result, lhs, rhs }
    }
}
pub enum F32Min {}
impl crate::BinaryCommutativeOperator for F32Min {
    const NAME: &'static ::core::primitive::str = "F32Min";
    type Imm = ::core::primitive::f32;
    type OpRri = crate::op::F32Min_RRI;
    type OpRrs = crate::op::F32Min_RRS;
    type OpRsi = crate::op::F32Min_RSI;
    type OpRss = crate::op::F32Min_RSS;
    type OpSri = crate::op::F32Min_SRI;
    type OpSrs = crate::op::F32Min_SRS;
    type OpSsi = crate::op::F32Min_SSI;
    type OpSss = crate::op::F32Min_SSS;
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
    fn make_sri(result: crate::Stack, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpSri {
        Self::OpSri { result, lhs, rhs }
    }
    fn make_srs(result: crate::Stack, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpSrs {
        Self::OpSrs { result, lhs, rhs }
    }
    fn make_ssi(result: crate::Stack, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpSsi {
        Self::OpSsi { result, lhs, rhs }
    }
    fn make_sss(result: crate::Stack, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpSss {
        Self::OpSss { result, lhs, rhs }
    }
}
pub enum F64Min {}
impl crate::BinaryCommutativeOperator for F64Min {
    const NAME: &'static ::core::primitive::str = "F64Min";
    type Imm = ::core::primitive::f64;
    type OpRri = crate::op::F64Min_RRI;
    type OpRrs = crate::op::F64Min_RRS;
    type OpRsi = crate::op::F64Min_RSI;
    type OpRss = crate::op::F64Min_RSS;
    type OpSri = crate::op::F64Min_SRI;
    type OpSrs = crate::op::F64Min_SRS;
    type OpSsi = crate::op::F64Min_SSI;
    type OpSss = crate::op::F64Min_SSS;
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
    fn make_sri(result: crate::Stack, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpSri {
        Self::OpSri { result, lhs, rhs }
    }
    fn make_srs(result: crate::Stack, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpSrs {
        Self::OpSrs { result, lhs, rhs }
    }
    fn make_ssi(result: crate::Stack, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpSsi {
        Self::OpSsi { result, lhs, rhs }
    }
    fn make_sss(result: crate::Stack, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpSss {
        Self::OpSss { result, lhs, rhs }
    }
}
pub enum F32Max {}
impl crate::BinaryCommutativeOperator for F32Max {
    const NAME: &'static ::core::primitive::str = "F32Max";
    type Imm = ::core::primitive::f32;
    type OpRri = crate::op::F32Max_RRI;
    type OpRrs = crate::op::F32Max_RRS;
    type OpRsi = crate::op::F32Max_RSI;
    type OpRss = crate::op::F32Max_RSS;
    type OpSri = crate::op::F32Max_SRI;
    type OpSrs = crate::op::F32Max_SRS;
    type OpSsi = crate::op::F32Max_SSI;
    type OpSss = crate::op::F32Max_SSS;
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
    fn make_sri(result: crate::Stack, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpSri {
        Self::OpSri { result, lhs, rhs }
    }
    fn make_srs(result: crate::Stack, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpSrs {
        Self::OpSrs { result, lhs, rhs }
    }
    fn make_ssi(result: crate::Stack, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpSsi {
        Self::OpSsi { result, lhs, rhs }
    }
    fn make_sss(result: crate::Stack, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpSss {
        Self::OpSss { result, lhs, rhs }
    }
}
pub enum F64Max {}
impl crate::BinaryCommutativeOperator for F64Max {
    const NAME: &'static ::core::primitive::str = "F64Max";
    type Imm = ::core::primitive::f64;
    type OpRri = crate::op::F64Max_RRI;
    type OpRrs = crate::op::F64Max_RRS;
    type OpRsi = crate::op::F64Max_RSI;
    type OpRss = crate::op::F64Max_RSS;
    type OpSri = crate::op::F64Max_SRI;
    type OpSrs = crate::op::F64Max_SRS;
    type OpSsi = crate::op::F64Max_SSI;
    type OpSss = crate::op::F64Max_SSS;
    fn make_rri(result: crate::Reg, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpRri {
        Self::OpRri { result, lhs, rhs }
    }
    fn make_rrs(result: crate::Reg, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpRrs {
        Self::OpRrs { result, lhs, rhs }
    }
    fn make_rsi(result: crate::Reg, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpRsi {
        Self::OpRsi { result, lhs, rhs }
    }
    fn make_rss(result: crate::Reg, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpRss {
        Self::OpRss { result, lhs, rhs }
    }
    fn make_sri(result: crate::Stack, lhs: crate::Reg, rhs: Self::Imm) -> Self::OpSri {
        Self::OpSri { result, lhs, rhs }
    }
    fn make_srs(result: crate::Stack, lhs: crate::Reg, rhs: crate::Stack) -> Self::OpSrs {
        Self::OpSrs { result, lhs, rhs }
    }
    fn make_ssi(result: crate::Stack, lhs: crate::Stack, rhs: Self::Imm) -> Self::OpSsi {
        Self::OpSsi { result, lhs, rhs }
    }
    fn make_sss(result: crate::Stack, lhs: crate::Stack, rhs: crate::Stack) -> Self::OpSss {
        Self::OpSss { result, lhs, rhs }
    }
}