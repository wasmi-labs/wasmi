// This file is automatically generated by the `build.rs` script.
//
// Do _not_ edit this file directly but change `build.rs` script logic instead.

pub enum I32Load {}
impl crate::LoadOperator for I32Load {
    const NAME: &'static ::core::primitive::str = "I32Load";
    type OpMem0Ri = crate::op::I32LoadMem0_RI;
    type OpMem0Rr = crate::op::I32LoadMem0_RR;
    type OpMem0Rs = crate::op::I32LoadMem0_RS;
    type OpMem0Si = crate::op::I32LoadMem0_SI;
    type OpMem0Sr = crate::op::I32LoadMem0_SR;
    type OpMem0Ss = crate::op::I32LoadMem0_SS;
    type OpRi = crate::op::I32Load_RI;
    type OpRr = crate::op::I32Load_RR;
    type OpRs = crate::op::I32Load_RS;
    fn make_mem0_ri(result: crate::Reg, address: crate::Address) -> Self::OpMem0Ri {
        Self::OpMem0Ri { result, address }
    }
    fn make_mem0_rr(result: crate::Reg, ptr: crate::Reg, offset: crate::Offset) -> Self::OpMem0Rr {
        Self::OpMem0Rr { result, ptr, offset }
    }
    fn make_mem0_rs(result: crate::Reg, ptr: crate::Stack, offset: crate::Offset) -> Self::OpMem0Rs {
        Self::OpMem0Rs { result, ptr, offset }
    }
    fn make_mem0_si(result: crate::Stack, address: crate::Address) -> Self::OpMem0Si {
        Self::OpMem0Si { result, address }
    }
    fn make_mem0_sr(result: crate::Stack, ptr: crate::Reg, offset: crate::Offset) -> Self::OpMem0Sr {
        Self::OpMem0Sr { result, ptr, offset }
    }
    fn make_mem0_ss(result: crate::Stack, ptr: crate::Stack, offset: crate::Offset) -> Self::OpMem0Ss {
        Self::OpMem0Ss { result, ptr, offset }
    }
    fn make_ri(result: crate::Reg, address: crate::Address, memory: crate::Memory) -> Self::OpRi {
        Self::OpRi { result, address, memory }
    }
    fn make_rr(result: crate::Reg, ptr: crate::Reg, offset: crate::Offset, memory: crate::Memory) -> Self::OpRr {
        Self::OpRr { result, ptr, memory, offset }
    }
    fn make_rs(result: crate::Reg, ptr: crate::Stack, offset: crate::Offset, memory: crate::Memory) -> Self::OpRs {
        Self::OpRs { result, ptr, memory, offset }
    }
}
pub enum I64Load {}
impl crate::LoadOperator for I64Load {
    const NAME: &'static ::core::primitive::str = "I64Load";
    type OpMem0Ri = crate::op::I64LoadMem0_RI;
    type OpMem0Rr = crate::op::I64LoadMem0_RR;
    type OpMem0Rs = crate::op::I64LoadMem0_RS;
    type OpMem0Si = crate::op::I64LoadMem0_SI;
    type OpMem0Sr = crate::op::I64LoadMem0_SR;
    type OpMem0Ss = crate::op::I64LoadMem0_SS;
    type OpRi = crate::op::I64Load_RI;
    type OpRr = crate::op::I64Load_RR;
    type OpRs = crate::op::I64Load_RS;
    fn make_mem0_ri(result: crate::Reg, address: crate::Address) -> Self::OpMem0Ri {
        Self::OpMem0Ri { result, address }
    }
    fn make_mem0_rr(result: crate::Reg, ptr: crate::Reg, offset: crate::Offset) -> Self::OpMem0Rr {
        Self::OpMem0Rr { result, ptr, offset }
    }
    fn make_mem0_rs(result: crate::Reg, ptr: crate::Stack, offset: crate::Offset) -> Self::OpMem0Rs {
        Self::OpMem0Rs { result, ptr, offset }
    }
    fn make_mem0_si(result: crate::Stack, address: crate::Address) -> Self::OpMem0Si {
        Self::OpMem0Si { result, address }
    }
    fn make_mem0_sr(result: crate::Stack, ptr: crate::Reg, offset: crate::Offset) -> Self::OpMem0Sr {
        Self::OpMem0Sr { result, ptr, offset }
    }
    fn make_mem0_ss(result: crate::Stack, ptr: crate::Stack, offset: crate::Offset) -> Self::OpMem0Ss {
        Self::OpMem0Ss { result, ptr, offset }
    }
    fn make_ri(result: crate::Reg, address: crate::Address, memory: crate::Memory) -> Self::OpRi {
        Self::OpRi { result, address, memory }
    }
    fn make_rr(result: crate::Reg, ptr: crate::Reg, offset: crate::Offset, memory: crate::Memory) -> Self::OpRr {
        Self::OpRr { result, ptr, memory, offset }
    }
    fn make_rs(result: crate::Reg, ptr: crate::Stack, offset: crate::Offset, memory: crate::Memory) -> Self::OpRs {
        Self::OpRs { result, ptr, memory, offset }
    }
}
pub enum F32Load {}
impl crate::LoadOperator for F32Load {
    const NAME: &'static ::core::primitive::str = "F32Load";
    type OpMem0Ri = crate::op::F32LoadMem0_RI;
    type OpMem0Rr = crate::op::F32LoadMem0_RR;
    type OpMem0Rs = crate::op::F32LoadMem0_RS;
    type OpMem0Si = crate::op::F32LoadMem0_SI;
    type OpMem0Sr = crate::op::F32LoadMem0_SR;
    type OpMem0Ss = crate::op::F32LoadMem0_SS;
    type OpRi = crate::op::F32Load_RI;
    type OpRr = crate::op::F32Load_RR;
    type OpRs = crate::op::F32Load_RS;
    fn make_mem0_ri(result: crate::Reg, address: crate::Address) -> Self::OpMem0Ri {
        Self::OpMem0Ri { result, address }
    }
    fn make_mem0_rr(result: crate::Reg, ptr: crate::Reg, offset: crate::Offset) -> Self::OpMem0Rr {
        Self::OpMem0Rr { result, ptr, offset }
    }
    fn make_mem0_rs(result: crate::Reg, ptr: crate::Stack, offset: crate::Offset) -> Self::OpMem0Rs {
        Self::OpMem0Rs { result, ptr, offset }
    }
    fn make_mem0_si(result: crate::Stack, address: crate::Address) -> Self::OpMem0Si {
        Self::OpMem0Si { result, address }
    }
    fn make_mem0_sr(result: crate::Stack, ptr: crate::Reg, offset: crate::Offset) -> Self::OpMem0Sr {
        Self::OpMem0Sr { result, ptr, offset }
    }
    fn make_mem0_ss(result: crate::Stack, ptr: crate::Stack, offset: crate::Offset) -> Self::OpMem0Ss {
        Self::OpMem0Ss { result, ptr, offset }
    }
    fn make_ri(result: crate::Reg, address: crate::Address, memory: crate::Memory) -> Self::OpRi {
        Self::OpRi { result, address, memory }
    }
    fn make_rr(result: crate::Reg, ptr: crate::Reg, offset: crate::Offset, memory: crate::Memory) -> Self::OpRr {
        Self::OpRr { result, ptr, memory, offset }
    }
    fn make_rs(result: crate::Reg, ptr: crate::Stack, offset: crate::Offset, memory: crate::Memory) -> Self::OpRs {
        Self::OpRs { result, ptr, memory, offset }
    }
}
pub enum F64Load {}
impl crate::LoadOperator for F64Load {
    const NAME: &'static ::core::primitive::str = "F64Load";
    type OpMem0Ri = crate::op::F64LoadMem0_RI;
    type OpMem0Rr = crate::op::F64LoadMem0_RR;
    type OpMem0Rs = crate::op::F64LoadMem0_RS;
    type OpMem0Si = crate::op::F64LoadMem0_SI;
    type OpMem0Sr = crate::op::F64LoadMem0_SR;
    type OpMem0Ss = crate::op::F64LoadMem0_SS;
    type OpRi = crate::op::F64Load_RI;
    type OpRr = crate::op::F64Load_RR;
    type OpRs = crate::op::F64Load_RS;
    fn make_mem0_ri(result: crate::Reg, address: crate::Address) -> Self::OpMem0Ri {
        Self::OpMem0Ri { result, address }
    }
    fn make_mem0_rr(result: crate::Reg, ptr: crate::Reg, offset: crate::Offset) -> Self::OpMem0Rr {
        Self::OpMem0Rr { result, ptr, offset }
    }
    fn make_mem0_rs(result: crate::Reg, ptr: crate::Stack, offset: crate::Offset) -> Self::OpMem0Rs {
        Self::OpMem0Rs { result, ptr, offset }
    }
    fn make_mem0_si(result: crate::Stack, address: crate::Address) -> Self::OpMem0Si {
        Self::OpMem0Si { result, address }
    }
    fn make_mem0_sr(result: crate::Stack, ptr: crate::Reg, offset: crate::Offset) -> Self::OpMem0Sr {
        Self::OpMem0Sr { result, ptr, offset }
    }
    fn make_mem0_ss(result: crate::Stack, ptr: crate::Stack, offset: crate::Offset) -> Self::OpMem0Ss {
        Self::OpMem0Ss { result, ptr, offset }
    }
    fn make_ri(result: crate::Reg, address: crate::Address, memory: crate::Memory) -> Self::OpRi {
        Self::OpRi { result, address, memory }
    }
    fn make_rr(result: crate::Reg, ptr: crate::Reg, offset: crate::Offset, memory: crate::Memory) -> Self::OpRr {
        Self::OpRr { result, ptr, memory, offset }
    }
    fn make_rs(result: crate::Reg, ptr: crate::Stack, offset: crate::Offset, memory: crate::Memory) -> Self::OpRs {
        Self::OpRs { result, ptr, memory, offset }
    }
}
pub enum I32Load8S {}
impl crate::LoadOperator for I32Load8S {
    const NAME: &'static ::core::primitive::str = "I32Load8S";
    type OpMem0Ri = crate::op::I32Load8SMem0_RI;
    type OpMem0Rr = crate::op::I32Load8SMem0_RR;
    type OpMem0Rs = crate::op::I32Load8SMem0_RS;
    type OpMem0Si = crate::op::I32Load8SMem0_SI;
    type OpMem0Sr = crate::op::I32Load8SMem0_SR;
    type OpMem0Ss = crate::op::I32Load8SMem0_SS;
    type OpRi = crate::op::I32Load8S_RI;
    type OpRr = crate::op::I32Load8S_RR;
    type OpRs = crate::op::I32Load8S_RS;
    fn make_mem0_ri(result: crate::Reg, address: crate::Address) -> Self::OpMem0Ri {
        Self::OpMem0Ri { result, address }
    }
    fn make_mem0_rr(result: crate::Reg, ptr: crate::Reg, offset: crate::Offset) -> Self::OpMem0Rr {
        Self::OpMem0Rr { result, ptr, offset }
    }
    fn make_mem0_rs(result: crate::Reg, ptr: crate::Stack, offset: crate::Offset) -> Self::OpMem0Rs {
        Self::OpMem0Rs { result, ptr, offset }
    }
    fn make_mem0_si(result: crate::Stack, address: crate::Address) -> Self::OpMem0Si {
        Self::OpMem0Si { result, address }
    }
    fn make_mem0_sr(result: crate::Stack, ptr: crate::Reg, offset: crate::Offset) -> Self::OpMem0Sr {
        Self::OpMem0Sr { result, ptr, offset }
    }
    fn make_mem0_ss(result: crate::Stack, ptr: crate::Stack, offset: crate::Offset) -> Self::OpMem0Ss {
        Self::OpMem0Ss { result, ptr, offset }
    }
    fn make_ri(result: crate::Reg, address: crate::Address, memory: crate::Memory) -> Self::OpRi {
        Self::OpRi { result, address, memory }
    }
    fn make_rr(result: crate::Reg, ptr: crate::Reg, offset: crate::Offset, memory: crate::Memory) -> Self::OpRr {
        Self::OpRr { result, ptr, memory, offset }
    }
    fn make_rs(result: crate::Reg, ptr: crate::Stack, offset: crate::Offset, memory: crate::Memory) -> Self::OpRs {
        Self::OpRs { result, ptr, memory, offset }
    }
}
pub enum I64Load8S {}
impl crate::LoadOperator for I64Load8S {
    const NAME: &'static ::core::primitive::str = "I64Load8S";
    type OpMem0Ri = crate::op::I64Load8SMem0_RI;
    type OpMem0Rr = crate::op::I64Load8SMem0_RR;
    type OpMem0Rs = crate::op::I64Load8SMem0_RS;
    type OpMem0Si = crate::op::I64Load8SMem0_SI;
    type OpMem0Sr = crate::op::I64Load8SMem0_SR;
    type OpMem0Ss = crate::op::I64Load8SMem0_SS;
    type OpRi = crate::op::I64Load8S_RI;
    type OpRr = crate::op::I64Load8S_RR;
    type OpRs = crate::op::I64Load8S_RS;
    fn make_mem0_ri(result: crate::Reg, address: crate::Address) -> Self::OpMem0Ri {
        Self::OpMem0Ri { result, address }
    }
    fn make_mem0_rr(result: crate::Reg, ptr: crate::Reg, offset: crate::Offset) -> Self::OpMem0Rr {
        Self::OpMem0Rr { result, ptr, offset }
    }
    fn make_mem0_rs(result: crate::Reg, ptr: crate::Stack, offset: crate::Offset) -> Self::OpMem0Rs {
        Self::OpMem0Rs { result, ptr, offset }
    }
    fn make_mem0_si(result: crate::Stack, address: crate::Address) -> Self::OpMem0Si {
        Self::OpMem0Si { result, address }
    }
    fn make_mem0_sr(result: crate::Stack, ptr: crate::Reg, offset: crate::Offset) -> Self::OpMem0Sr {
        Self::OpMem0Sr { result, ptr, offset }
    }
    fn make_mem0_ss(result: crate::Stack, ptr: crate::Stack, offset: crate::Offset) -> Self::OpMem0Ss {
        Self::OpMem0Ss { result, ptr, offset }
    }
    fn make_ri(result: crate::Reg, address: crate::Address, memory: crate::Memory) -> Self::OpRi {
        Self::OpRi { result, address, memory }
    }
    fn make_rr(result: crate::Reg, ptr: crate::Reg, offset: crate::Offset, memory: crate::Memory) -> Self::OpRr {
        Self::OpRr { result, ptr, memory, offset }
    }
    fn make_rs(result: crate::Reg, ptr: crate::Stack, offset: crate::Offset, memory: crate::Memory) -> Self::OpRs {
        Self::OpRs { result, ptr, memory, offset }
    }
}
pub enum I32Load8U {}
impl crate::LoadOperator for I32Load8U {
    const NAME: &'static ::core::primitive::str = "I32Load8U";
    type OpMem0Ri = crate::op::I32Load8UMem0_RI;
    type OpMem0Rr = crate::op::I32Load8UMem0_RR;
    type OpMem0Rs = crate::op::I32Load8UMem0_RS;
    type OpMem0Si = crate::op::I32Load8UMem0_SI;
    type OpMem0Sr = crate::op::I32Load8UMem0_SR;
    type OpMem0Ss = crate::op::I32Load8UMem0_SS;
    type OpRi = crate::op::I32Load8U_RI;
    type OpRr = crate::op::I32Load8U_RR;
    type OpRs = crate::op::I32Load8U_RS;
    fn make_mem0_ri(result: crate::Reg, address: crate::Address) -> Self::OpMem0Ri {
        Self::OpMem0Ri { result, address }
    }
    fn make_mem0_rr(result: crate::Reg, ptr: crate::Reg, offset: crate::Offset) -> Self::OpMem0Rr {
        Self::OpMem0Rr { result, ptr, offset }
    }
    fn make_mem0_rs(result: crate::Reg, ptr: crate::Stack, offset: crate::Offset) -> Self::OpMem0Rs {
        Self::OpMem0Rs { result, ptr, offset }
    }
    fn make_mem0_si(result: crate::Stack, address: crate::Address) -> Self::OpMem0Si {
        Self::OpMem0Si { result, address }
    }
    fn make_mem0_sr(result: crate::Stack, ptr: crate::Reg, offset: crate::Offset) -> Self::OpMem0Sr {
        Self::OpMem0Sr { result, ptr, offset }
    }
    fn make_mem0_ss(result: crate::Stack, ptr: crate::Stack, offset: crate::Offset) -> Self::OpMem0Ss {
        Self::OpMem0Ss { result, ptr, offset }
    }
    fn make_ri(result: crate::Reg, address: crate::Address, memory: crate::Memory) -> Self::OpRi {
        Self::OpRi { result, address, memory }
    }
    fn make_rr(result: crate::Reg, ptr: crate::Reg, offset: crate::Offset, memory: crate::Memory) -> Self::OpRr {
        Self::OpRr { result, ptr, memory, offset }
    }
    fn make_rs(result: crate::Reg, ptr: crate::Stack, offset: crate::Offset, memory: crate::Memory) -> Self::OpRs {
        Self::OpRs { result, ptr, memory, offset }
    }
}
pub enum I64Load8U {}
impl crate::LoadOperator for I64Load8U {
    const NAME: &'static ::core::primitive::str = "I64Load8U";
    type OpMem0Ri = crate::op::I64Load8UMem0_RI;
    type OpMem0Rr = crate::op::I64Load8UMem0_RR;
    type OpMem0Rs = crate::op::I64Load8UMem0_RS;
    type OpMem0Si = crate::op::I64Load8UMem0_SI;
    type OpMem0Sr = crate::op::I64Load8UMem0_SR;
    type OpMem0Ss = crate::op::I64Load8UMem0_SS;
    type OpRi = crate::op::I64Load8U_RI;
    type OpRr = crate::op::I64Load8U_RR;
    type OpRs = crate::op::I64Load8U_RS;
    fn make_mem0_ri(result: crate::Reg, address: crate::Address) -> Self::OpMem0Ri {
        Self::OpMem0Ri { result, address }
    }
    fn make_mem0_rr(result: crate::Reg, ptr: crate::Reg, offset: crate::Offset) -> Self::OpMem0Rr {
        Self::OpMem0Rr { result, ptr, offset }
    }
    fn make_mem0_rs(result: crate::Reg, ptr: crate::Stack, offset: crate::Offset) -> Self::OpMem0Rs {
        Self::OpMem0Rs { result, ptr, offset }
    }
    fn make_mem0_si(result: crate::Stack, address: crate::Address) -> Self::OpMem0Si {
        Self::OpMem0Si { result, address }
    }
    fn make_mem0_sr(result: crate::Stack, ptr: crate::Reg, offset: crate::Offset) -> Self::OpMem0Sr {
        Self::OpMem0Sr { result, ptr, offset }
    }
    fn make_mem0_ss(result: crate::Stack, ptr: crate::Stack, offset: crate::Offset) -> Self::OpMem0Ss {
        Self::OpMem0Ss { result, ptr, offset }
    }
    fn make_ri(result: crate::Reg, address: crate::Address, memory: crate::Memory) -> Self::OpRi {
        Self::OpRi { result, address, memory }
    }
    fn make_rr(result: crate::Reg, ptr: crate::Reg, offset: crate::Offset, memory: crate::Memory) -> Self::OpRr {
        Self::OpRr { result, ptr, memory, offset }
    }
    fn make_rs(result: crate::Reg, ptr: crate::Stack, offset: crate::Offset, memory: crate::Memory) -> Self::OpRs {
        Self::OpRs { result, ptr, memory, offset }
    }
}
pub enum I32Load16S {}
impl crate::LoadOperator for I32Load16S {
    const NAME: &'static ::core::primitive::str = "I32Load16S";
    type OpMem0Ri = crate::op::I32Load16SMem0_RI;
    type OpMem0Rr = crate::op::I32Load16SMem0_RR;
    type OpMem0Rs = crate::op::I32Load16SMem0_RS;
    type OpMem0Si = crate::op::I32Load16SMem0_SI;
    type OpMem0Sr = crate::op::I32Load16SMem0_SR;
    type OpMem0Ss = crate::op::I32Load16SMem0_SS;
    type OpRi = crate::op::I32Load16S_RI;
    type OpRr = crate::op::I32Load16S_RR;
    type OpRs = crate::op::I32Load16S_RS;
    fn make_mem0_ri(result: crate::Reg, address: crate::Address) -> Self::OpMem0Ri {
        Self::OpMem0Ri { result, address }
    }
    fn make_mem0_rr(result: crate::Reg, ptr: crate::Reg, offset: crate::Offset) -> Self::OpMem0Rr {
        Self::OpMem0Rr { result, ptr, offset }
    }
    fn make_mem0_rs(result: crate::Reg, ptr: crate::Stack, offset: crate::Offset) -> Self::OpMem0Rs {
        Self::OpMem0Rs { result, ptr, offset }
    }
    fn make_mem0_si(result: crate::Stack, address: crate::Address) -> Self::OpMem0Si {
        Self::OpMem0Si { result, address }
    }
    fn make_mem0_sr(result: crate::Stack, ptr: crate::Reg, offset: crate::Offset) -> Self::OpMem0Sr {
        Self::OpMem0Sr { result, ptr, offset }
    }
    fn make_mem0_ss(result: crate::Stack, ptr: crate::Stack, offset: crate::Offset) -> Self::OpMem0Ss {
        Self::OpMem0Ss { result, ptr, offset }
    }
    fn make_ri(result: crate::Reg, address: crate::Address, memory: crate::Memory) -> Self::OpRi {
        Self::OpRi { result, address, memory }
    }
    fn make_rr(result: crate::Reg, ptr: crate::Reg, offset: crate::Offset, memory: crate::Memory) -> Self::OpRr {
        Self::OpRr { result, ptr, memory, offset }
    }
    fn make_rs(result: crate::Reg, ptr: crate::Stack, offset: crate::Offset, memory: crate::Memory) -> Self::OpRs {
        Self::OpRs { result, ptr, memory, offset }
    }
}
pub enum I64Load16S {}
impl crate::LoadOperator for I64Load16S {
    const NAME: &'static ::core::primitive::str = "I64Load16S";
    type OpMem0Ri = crate::op::I64Load16SMem0_RI;
    type OpMem0Rr = crate::op::I64Load16SMem0_RR;
    type OpMem0Rs = crate::op::I64Load16SMem0_RS;
    type OpMem0Si = crate::op::I64Load16SMem0_SI;
    type OpMem0Sr = crate::op::I64Load16SMem0_SR;
    type OpMem0Ss = crate::op::I64Load16SMem0_SS;
    type OpRi = crate::op::I64Load16S_RI;
    type OpRr = crate::op::I64Load16S_RR;
    type OpRs = crate::op::I64Load16S_RS;
    fn make_mem0_ri(result: crate::Reg, address: crate::Address) -> Self::OpMem0Ri {
        Self::OpMem0Ri { result, address }
    }
    fn make_mem0_rr(result: crate::Reg, ptr: crate::Reg, offset: crate::Offset) -> Self::OpMem0Rr {
        Self::OpMem0Rr { result, ptr, offset }
    }
    fn make_mem0_rs(result: crate::Reg, ptr: crate::Stack, offset: crate::Offset) -> Self::OpMem0Rs {
        Self::OpMem0Rs { result, ptr, offset }
    }
    fn make_mem0_si(result: crate::Stack, address: crate::Address) -> Self::OpMem0Si {
        Self::OpMem0Si { result, address }
    }
    fn make_mem0_sr(result: crate::Stack, ptr: crate::Reg, offset: crate::Offset) -> Self::OpMem0Sr {
        Self::OpMem0Sr { result, ptr, offset }
    }
    fn make_mem0_ss(result: crate::Stack, ptr: crate::Stack, offset: crate::Offset) -> Self::OpMem0Ss {
        Self::OpMem0Ss { result, ptr, offset }
    }
    fn make_ri(result: crate::Reg, address: crate::Address, memory: crate::Memory) -> Self::OpRi {
        Self::OpRi { result, address, memory }
    }
    fn make_rr(result: crate::Reg, ptr: crate::Reg, offset: crate::Offset, memory: crate::Memory) -> Self::OpRr {
        Self::OpRr { result, ptr, memory, offset }
    }
    fn make_rs(result: crate::Reg, ptr: crate::Stack, offset: crate::Offset, memory: crate::Memory) -> Self::OpRs {
        Self::OpRs { result, ptr, memory, offset }
    }
}
pub enum I32Load16U {}
impl crate::LoadOperator for I32Load16U {
    const NAME: &'static ::core::primitive::str = "I32Load16U";
    type OpMem0Ri = crate::op::I32Load16UMem0_RI;
    type OpMem0Rr = crate::op::I32Load16UMem0_RR;
    type OpMem0Rs = crate::op::I32Load16UMem0_RS;
    type OpMem0Si = crate::op::I32Load16UMem0_SI;
    type OpMem0Sr = crate::op::I32Load16UMem0_SR;
    type OpMem0Ss = crate::op::I32Load16UMem0_SS;
    type OpRi = crate::op::I32Load16U_RI;
    type OpRr = crate::op::I32Load16U_RR;
    type OpRs = crate::op::I32Load16U_RS;
    fn make_mem0_ri(result: crate::Reg, address: crate::Address) -> Self::OpMem0Ri {
        Self::OpMem0Ri { result, address }
    }
    fn make_mem0_rr(result: crate::Reg, ptr: crate::Reg, offset: crate::Offset) -> Self::OpMem0Rr {
        Self::OpMem0Rr { result, ptr, offset }
    }
    fn make_mem0_rs(result: crate::Reg, ptr: crate::Stack, offset: crate::Offset) -> Self::OpMem0Rs {
        Self::OpMem0Rs { result, ptr, offset }
    }
    fn make_mem0_si(result: crate::Stack, address: crate::Address) -> Self::OpMem0Si {
        Self::OpMem0Si { result, address }
    }
    fn make_mem0_sr(result: crate::Stack, ptr: crate::Reg, offset: crate::Offset) -> Self::OpMem0Sr {
        Self::OpMem0Sr { result, ptr, offset }
    }
    fn make_mem0_ss(result: crate::Stack, ptr: crate::Stack, offset: crate::Offset) -> Self::OpMem0Ss {
        Self::OpMem0Ss { result, ptr, offset }
    }
    fn make_ri(result: crate::Reg, address: crate::Address, memory: crate::Memory) -> Self::OpRi {
        Self::OpRi { result, address, memory }
    }
    fn make_rr(result: crate::Reg, ptr: crate::Reg, offset: crate::Offset, memory: crate::Memory) -> Self::OpRr {
        Self::OpRr { result, ptr, memory, offset }
    }
    fn make_rs(result: crate::Reg, ptr: crate::Stack, offset: crate::Offset, memory: crate::Memory) -> Self::OpRs {
        Self::OpRs { result, ptr, memory, offset }
    }
}
pub enum I64Load16U {}
impl crate::LoadOperator for I64Load16U {
    const NAME: &'static ::core::primitive::str = "I64Load16U";
    type OpMem0Ri = crate::op::I64Load16UMem0_RI;
    type OpMem0Rr = crate::op::I64Load16UMem0_RR;
    type OpMem0Rs = crate::op::I64Load16UMem0_RS;
    type OpMem0Si = crate::op::I64Load16UMem0_SI;
    type OpMem0Sr = crate::op::I64Load16UMem0_SR;
    type OpMem0Ss = crate::op::I64Load16UMem0_SS;
    type OpRi = crate::op::I64Load16U_RI;
    type OpRr = crate::op::I64Load16U_RR;
    type OpRs = crate::op::I64Load16U_RS;
    fn make_mem0_ri(result: crate::Reg, address: crate::Address) -> Self::OpMem0Ri {
        Self::OpMem0Ri { result, address }
    }
    fn make_mem0_rr(result: crate::Reg, ptr: crate::Reg, offset: crate::Offset) -> Self::OpMem0Rr {
        Self::OpMem0Rr { result, ptr, offset }
    }
    fn make_mem0_rs(result: crate::Reg, ptr: crate::Stack, offset: crate::Offset) -> Self::OpMem0Rs {
        Self::OpMem0Rs { result, ptr, offset }
    }
    fn make_mem0_si(result: crate::Stack, address: crate::Address) -> Self::OpMem0Si {
        Self::OpMem0Si { result, address }
    }
    fn make_mem0_sr(result: crate::Stack, ptr: crate::Reg, offset: crate::Offset) -> Self::OpMem0Sr {
        Self::OpMem0Sr { result, ptr, offset }
    }
    fn make_mem0_ss(result: crate::Stack, ptr: crate::Stack, offset: crate::Offset) -> Self::OpMem0Ss {
        Self::OpMem0Ss { result, ptr, offset }
    }
    fn make_ri(result: crate::Reg, address: crate::Address, memory: crate::Memory) -> Self::OpRi {
        Self::OpRi { result, address, memory }
    }
    fn make_rr(result: crate::Reg, ptr: crate::Reg, offset: crate::Offset, memory: crate::Memory) -> Self::OpRr {
        Self::OpRr { result, ptr, memory, offset }
    }
    fn make_rs(result: crate::Reg, ptr: crate::Stack, offset: crate::Offset, memory: crate::Memory) -> Self::OpRs {
        Self::OpRs { result, ptr, memory, offset }
    }
}
pub enum I64Load32S {}
impl crate::LoadOperator for I64Load32S {
    const NAME: &'static ::core::primitive::str = "I64Load32S";
    type OpMem0Ri = crate::op::I64Load32SMem0_RI;
    type OpMem0Rr = crate::op::I64Load32SMem0_RR;
    type OpMem0Rs = crate::op::I64Load32SMem0_RS;
    type OpMem0Si = crate::op::I64Load32SMem0_SI;
    type OpMem0Sr = crate::op::I64Load32SMem0_SR;
    type OpMem0Ss = crate::op::I64Load32SMem0_SS;
    type OpRi = crate::op::I64Load32S_RI;
    type OpRr = crate::op::I64Load32S_RR;
    type OpRs = crate::op::I64Load32S_RS;
    fn make_mem0_ri(result: crate::Reg, address: crate::Address) -> Self::OpMem0Ri {
        Self::OpMem0Ri { result, address }
    }
    fn make_mem0_rr(result: crate::Reg, ptr: crate::Reg, offset: crate::Offset) -> Self::OpMem0Rr {
        Self::OpMem0Rr { result, ptr, offset }
    }
    fn make_mem0_rs(result: crate::Reg, ptr: crate::Stack, offset: crate::Offset) -> Self::OpMem0Rs {
        Self::OpMem0Rs { result, ptr, offset }
    }
    fn make_mem0_si(result: crate::Stack, address: crate::Address) -> Self::OpMem0Si {
        Self::OpMem0Si { result, address }
    }
    fn make_mem0_sr(result: crate::Stack, ptr: crate::Reg, offset: crate::Offset) -> Self::OpMem0Sr {
        Self::OpMem0Sr { result, ptr, offset }
    }
    fn make_mem0_ss(result: crate::Stack, ptr: crate::Stack, offset: crate::Offset) -> Self::OpMem0Ss {
        Self::OpMem0Ss { result, ptr, offset }
    }
    fn make_ri(result: crate::Reg, address: crate::Address, memory: crate::Memory) -> Self::OpRi {
        Self::OpRi { result, address, memory }
    }
    fn make_rr(result: crate::Reg, ptr: crate::Reg, offset: crate::Offset, memory: crate::Memory) -> Self::OpRr {
        Self::OpRr { result, ptr, memory, offset }
    }
    fn make_rs(result: crate::Reg, ptr: crate::Stack, offset: crate::Offset, memory: crate::Memory) -> Self::OpRs {
        Self::OpRs { result, ptr, memory, offset }
    }
}
pub enum I64Load32U {}
impl crate::LoadOperator for I64Load32U {
    const NAME: &'static ::core::primitive::str = "I64Load32U";
    type OpMem0Ri = crate::op::I64Load32UMem0_RI;
    type OpMem0Rr = crate::op::I64Load32UMem0_RR;
    type OpMem0Rs = crate::op::I64Load32UMem0_RS;
    type OpMem0Si = crate::op::I64Load32UMem0_SI;
    type OpMem0Sr = crate::op::I64Load32UMem0_SR;
    type OpMem0Ss = crate::op::I64Load32UMem0_SS;
    type OpRi = crate::op::I64Load32U_RI;
    type OpRr = crate::op::I64Load32U_RR;
    type OpRs = crate::op::I64Load32U_RS;
    fn make_mem0_ri(result: crate::Reg, address: crate::Address) -> Self::OpMem0Ri {
        Self::OpMem0Ri { result, address }
    }
    fn make_mem0_rr(result: crate::Reg, ptr: crate::Reg, offset: crate::Offset) -> Self::OpMem0Rr {
        Self::OpMem0Rr { result, ptr, offset }
    }
    fn make_mem0_rs(result: crate::Reg, ptr: crate::Stack, offset: crate::Offset) -> Self::OpMem0Rs {
        Self::OpMem0Rs { result, ptr, offset }
    }
    fn make_mem0_si(result: crate::Stack, address: crate::Address) -> Self::OpMem0Si {
        Self::OpMem0Si { result, address }
    }
    fn make_mem0_sr(result: crate::Stack, ptr: crate::Reg, offset: crate::Offset) -> Self::OpMem0Sr {
        Self::OpMem0Sr { result, ptr, offset }
    }
    fn make_mem0_ss(result: crate::Stack, ptr: crate::Stack, offset: crate::Offset) -> Self::OpMem0Ss {
        Self::OpMem0Ss { result, ptr, offset }
    }
    fn make_ri(result: crate::Reg, address: crate::Address, memory: crate::Memory) -> Self::OpRi {
        Self::OpRi { result, address, memory }
    }
    fn make_rr(result: crate::Reg, ptr: crate::Reg, offset: crate::Offset, memory: crate::Memory) -> Self::OpRr {
        Self::OpRr { result, ptr, memory, offset }
    }
    fn make_rs(result: crate::Reg, ptr: crate::Stack, offset: crate::Offset, memory: crate::Memory) -> Self::OpRs {
        Self::OpRs { result, ptr, memory, offset }
    }
}
