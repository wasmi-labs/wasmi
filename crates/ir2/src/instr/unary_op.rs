// This file is automatically generated by the `build.rs` script.
//
// Do _not_ edit this file directly but change `build.rs` script logic instead.

pub enum I32Popcnt {}
impl crate::UnaryOperator for I32Popcnt {
    const NAME: &'static ::core::primitive::str = "I32Popcnt";
    type OpRr = crate::op::I32Popcnt_RR;
    type OpRs = crate::op::I32Popcnt_RS;
    type OpSr = crate::op::I32Popcnt_SR;
    type OpSs = crate::op::I32Popcnt_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum I64Popcnt {}
impl crate::UnaryOperator for I64Popcnt {
    const NAME: &'static ::core::primitive::str = "I64Popcnt";
    type OpRr = crate::op::I64Popcnt_RR;
    type OpRs = crate::op::I64Popcnt_RS;
    type OpSr = crate::op::I64Popcnt_SR;
    type OpSs = crate::op::I64Popcnt_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum I32Clz {}
impl crate::UnaryOperator for I32Clz {
    const NAME: &'static ::core::primitive::str = "I32Clz";
    type OpRr = crate::op::I32Clz_RR;
    type OpRs = crate::op::I32Clz_RS;
    type OpSr = crate::op::I32Clz_SR;
    type OpSs = crate::op::I32Clz_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum I64Clz {}
impl crate::UnaryOperator for I64Clz {
    const NAME: &'static ::core::primitive::str = "I64Clz";
    type OpRr = crate::op::I64Clz_RR;
    type OpRs = crate::op::I64Clz_RS;
    type OpSr = crate::op::I64Clz_SR;
    type OpSs = crate::op::I64Clz_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum I32Ctz {}
impl crate::UnaryOperator for I32Ctz {
    const NAME: &'static ::core::primitive::str = "I32Ctz";
    type OpRr = crate::op::I32Ctz_RR;
    type OpRs = crate::op::I32Ctz_RS;
    type OpSr = crate::op::I32Ctz_SR;
    type OpSs = crate::op::I32Ctz_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum I64Ctz {}
impl crate::UnaryOperator for I64Ctz {
    const NAME: &'static ::core::primitive::str = "I64Ctz";
    type OpRr = crate::op::I64Ctz_RR;
    type OpRs = crate::op::I64Ctz_RS;
    type OpSr = crate::op::I64Ctz_SR;
    type OpSs = crate::op::I64Ctz_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum F32Abs {}
impl crate::UnaryOperator for F32Abs {
    const NAME: &'static ::core::primitive::str = "F32Abs";
    type OpRr = crate::op::F32Abs_RR;
    type OpRs = crate::op::F32Abs_RS;
    type OpSr = crate::op::F32Abs_SR;
    type OpSs = crate::op::F32Abs_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum F64Abs {}
impl crate::UnaryOperator for F64Abs {
    const NAME: &'static ::core::primitive::str = "F64Abs";
    type OpRr = crate::op::F64Abs_RR;
    type OpRs = crate::op::F64Abs_RS;
    type OpSr = crate::op::F64Abs_SR;
    type OpSs = crate::op::F64Abs_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum F32Neg {}
impl crate::UnaryOperator for F32Neg {
    const NAME: &'static ::core::primitive::str = "F32Neg";
    type OpRr = crate::op::F32Neg_RR;
    type OpRs = crate::op::F32Neg_RS;
    type OpSr = crate::op::F32Neg_SR;
    type OpSs = crate::op::F32Neg_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum F64Neg {}
impl crate::UnaryOperator for F64Neg {
    const NAME: &'static ::core::primitive::str = "F64Neg";
    type OpRr = crate::op::F64Neg_RR;
    type OpRs = crate::op::F64Neg_RS;
    type OpSr = crate::op::F64Neg_SR;
    type OpSs = crate::op::F64Neg_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum F32Ceil {}
impl crate::UnaryOperator for F32Ceil {
    const NAME: &'static ::core::primitive::str = "F32Ceil";
    type OpRr = crate::op::F32Ceil_RR;
    type OpRs = crate::op::F32Ceil_RS;
    type OpSr = crate::op::F32Ceil_SR;
    type OpSs = crate::op::F32Ceil_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum F64Ceil {}
impl crate::UnaryOperator for F64Ceil {
    const NAME: &'static ::core::primitive::str = "F64Ceil";
    type OpRr = crate::op::F64Ceil_RR;
    type OpRs = crate::op::F64Ceil_RS;
    type OpSr = crate::op::F64Ceil_SR;
    type OpSs = crate::op::F64Ceil_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum F32Floor {}
impl crate::UnaryOperator for F32Floor {
    const NAME: &'static ::core::primitive::str = "F32Floor";
    type OpRr = crate::op::F32Floor_RR;
    type OpRs = crate::op::F32Floor_RS;
    type OpSr = crate::op::F32Floor_SR;
    type OpSs = crate::op::F32Floor_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum F64Floor {}
impl crate::UnaryOperator for F64Floor {
    const NAME: &'static ::core::primitive::str = "F64Floor";
    type OpRr = crate::op::F64Floor_RR;
    type OpRs = crate::op::F64Floor_RS;
    type OpSr = crate::op::F64Floor_SR;
    type OpSs = crate::op::F64Floor_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum F32Trunc {}
impl crate::UnaryOperator for F32Trunc {
    const NAME: &'static ::core::primitive::str = "F32Trunc";
    type OpRr = crate::op::F32Trunc_RR;
    type OpRs = crate::op::F32Trunc_RS;
    type OpSr = crate::op::F32Trunc_SR;
    type OpSs = crate::op::F32Trunc_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum F64Trunc {}
impl crate::UnaryOperator for F64Trunc {
    const NAME: &'static ::core::primitive::str = "F64Trunc";
    type OpRr = crate::op::F64Trunc_RR;
    type OpRs = crate::op::F64Trunc_RS;
    type OpSr = crate::op::F64Trunc_SR;
    type OpSs = crate::op::F64Trunc_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum F32Nearest {}
impl crate::UnaryOperator for F32Nearest {
    const NAME: &'static ::core::primitive::str = "F32Nearest";
    type OpRr = crate::op::F32Nearest_RR;
    type OpRs = crate::op::F32Nearest_RS;
    type OpSr = crate::op::F32Nearest_SR;
    type OpSs = crate::op::F32Nearest_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum F64Nearest {}
impl crate::UnaryOperator for F64Nearest {
    const NAME: &'static ::core::primitive::str = "F64Nearest";
    type OpRr = crate::op::F64Nearest_RR;
    type OpRs = crate::op::F64Nearest_RS;
    type OpSr = crate::op::F64Nearest_SR;
    type OpSs = crate::op::F64Nearest_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum F32Sqrt {}
impl crate::UnaryOperator for F32Sqrt {
    const NAME: &'static ::core::primitive::str = "F32Sqrt";
    type OpRr = crate::op::F32Sqrt_RR;
    type OpRs = crate::op::F32Sqrt_RS;
    type OpSr = crate::op::F32Sqrt_SR;
    type OpSs = crate::op::F32Sqrt_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum F64Sqrt {}
impl crate::UnaryOperator for F64Sqrt {
    const NAME: &'static ::core::primitive::str = "F64Sqrt";
    type OpRr = crate::op::F64Sqrt_RR;
    type OpRs = crate::op::F64Sqrt_RS;
    type OpSr = crate::op::F64Sqrt_SR;
    type OpSs = crate::op::F64Sqrt_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum F32Demote {}
impl crate::UnaryOperator for F32Demote {
    const NAME: &'static ::core::primitive::str = "F32Demote";
    type OpRr = crate::op::F32Demote_RR;
    type OpRs = crate::op::F32Demote_RS;
    type OpSr = crate::op::F32Demote_SR;
    type OpSs = crate::op::F32Demote_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum F64Promote {}
impl crate::UnaryOperator for F64Promote {
    const NAME: &'static ::core::primitive::str = "F64Promote";
    type OpRr = crate::op::F64Promote_RR;
    type OpRs = crate::op::F64Promote_RS;
    type OpSr = crate::op::F64Promote_SR;
    type OpSs = crate::op::F64Promote_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum F32ConvertI32S {}
impl crate::UnaryOperator for F32ConvertI32S {
    const NAME: &'static ::core::primitive::str = "F32ConvertI32S";
    type OpRr = crate::op::F32ConvertI32S_RR;
    type OpRs = crate::op::F32ConvertI32S_RS;
    type OpSr = crate::op::F32ConvertI32S_SR;
    type OpSs = crate::op::F32ConvertI32S_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum F32ConvertI32U {}
impl crate::UnaryOperator for F32ConvertI32U {
    const NAME: &'static ::core::primitive::str = "F32ConvertI32U";
    type OpRr = crate::op::F32ConvertI32U_RR;
    type OpRs = crate::op::F32ConvertI32U_RS;
    type OpSr = crate::op::F32ConvertI32U_SR;
    type OpSs = crate::op::F32ConvertI32U_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum F32ConvertI64S {}
impl crate::UnaryOperator for F32ConvertI64S {
    const NAME: &'static ::core::primitive::str = "F32ConvertI64S";
    type OpRr = crate::op::F32ConvertI64S_RR;
    type OpRs = crate::op::F32ConvertI64S_RS;
    type OpSr = crate::op::F32ConvertI64S_SR;
    type OpSs = crate::op::F32ConvertI64S_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum F32ConvertI64U {}
impl crate::UnaryOperator for F32ConvertI64U {
    const NAME: &'static ::core::primitive::str = "F32ConvertI64U";
    type OpRr = crate::op::F32ConvertI64U_RR;
    type OpRs = crate::op::F32ConvertI64U_RS;
    type OpSr = crate::op::F32ConvertI64U_SR;
    type OpSs = crate::op::F32ConvertI64U_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum F64ConvertI32S {}
impl crate::UnaryOperator for F64ConvertI32S {
    const NAME: &'static ::core::primitive::str = "F64ConvertI32S";
    type OpRr = crate::op::F64ConvertI32S_RR;
    type OpRs = crate::op::F64ConvertI32S_RS;
    type OpSr = crate::op::F64ConvertI32S_SR;
    type OpSs = crate::op::F64ConvertI32S_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum F64ConvertI32U {}
impl crate::UnaryOperator for F64ConvertI32U {
    const NAME: &'static ::core::primitive::str = "F64ConvertI32U";
    type OpRr = crate::op::F64ConvertI32U_RR;
    type OpRs = crate::op::F64ConvertI32U_RS;
    type OpSr = crate::op::F64ConvertI32U_SR;
    type OpSs = crate::op::F64ConvertI32U_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum F64ConvertI64S {}
impl crate::UnaryOperator for F64ConvertI64S {
    const NAME: &'static ::core::primitive::str = "F64ConvertI64S";
    type OpRr = crate::op::F64ConvertI64S_RR;
    type OpRs = crate::op::F64ConvertI64S_RS;
    type OpSr = crate::op::F64ConvertI64S_SR;
    type OpSs = crate::op::F64ConvertI64S_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum F64ConvertI64U {}
impl crate::UnaryOperator for F64ConvertI64U {
    const NAME: &'static ::core::primitive::str = "F64ConvertI64U";
    type OpRr = crate::op::F64ConvertI64U_RR;
    type OpRs = crate::op::F64ConvertI64U_RS;
    type OpSr = crate::op::F64ConvertI64U_SR;
    type OpSs = crate::op::F64ConvertI64U_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum I32TruncF32S {}
impl crate::UnaryOperator for I32TruncF32S {
    const NAME: &'static ::core::primitive::str = "I32TruncF32S";
    type OpRr = crate::op::I32TruncF32S_RR;
    type OpRs = crate::op::I32TruncF32S_RS;
    type OpSr = crate::op::I32TruncF32S_SR;
    type OpSs = crate::op::I32TruncF32S_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum I32TruncF32U {}
impl crate::UnaryOperator for I32TruncF32U {
    const NAME: &'static ::core::primitive::str = "I32TruncF32U";
    type OpRr = crate::op::I32TruncF32U_RR;
    type OpRs = crate::op::I32TruncF32U_RS;
    type OpSr = crate::op::I32TruncF32U_SR;
    type OpSs = crate::op::I32TruncF32U_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum I32TruncF64S {}
impl crate::UnaryOperator for I32TruncF64S {
    const NAME: &'static ::core::primitive::str = "I32TruncF64S";
    type OpRr = crate::op::I32TruncF64S_RR;
    type OpRs = crate::op::I32TruncF64S_RS;
    type OpSr = crate::op::I32TruncF64S_SR;
    type OpSs = crate::op::I32TruncF64S_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum I32TruncF64U {}
impl crate::UnaryOperator for I32TruncF64U {
    const NAME: &'static ::core::primitive::str = "I32TruncF64U";
    type OpRr = crate::op::I32TruncF64U_RR;
    type OpRs = crate::op::I32TruncF64U_RS;
    type OpSr = crate::op::I32TruncF64U_SR;
    type OpSs = crate::op::I32TruncF64U_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum I64TruncF32S {}
impl crate::UnaryOperator for I64TruncF32S {
    const NAME: &'static ::core::primitive::str = "I64TruncF32S";
    type OpRr = crate::op::I64TruncF32S_RR;
    type OpRs = crate::op::I64TruncF32S_RS;
    type OpSr = crate::op::I64TruncF32S_SR;
    type OpSs = crate::op::I64TruncF32S_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum I64TruncF32U {}
impl crate::UnaryOperator for I64TruncF32U {
    const NAME: &'static ::core::primitive::str = "I64TruncF32U";
    type OpRr = crate::op::I64TruncF32U_RR;
    type OpRs = crate::op::I64TruncF32U_RS;
    type OpSr = crate::op::I64TruncF32U_SR;
    type OpSs = crate::op::I64TruncF32U_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum I64TruncF64S {}
impl crate::UnaryOperator for I64TruncF64S {
    const NAME: &'static ::core::primitive::str = "I64TruncF64S";
    type OpRr = crate::op::I64TruncF64S_RR;
    type OpRs = crate::op::I64TruncF64S_RS;
    type OpSr = crate::op::I64TruncF64S_SR;
    type OpSs = crate::op::I64TruncF64S_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum I64TruncF64U {}
impl crate::UnaryOperator for I64TruncF64U {
    const NAME: &'static ::core::primitive::str = "I64TruncF64U";
    type OpRr = crate::op::I64TruncF64U_RR;
    type OpRs = crate::op::I64TruncF64U_RS;
    type OpSr = crate::op::I64TruncF64U_SR;
    type OpSs = crate::op::I64TruncF64U_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum I32TruncSatF32S {}
impl crate::UnaryOperator for I32TruncSatF32S {
    const NAME: &'static ::core::primitive::str = "I32TruncSatF32S";
    type OpRr = crate::op::I32TruncSatF32S_RR;
    type OpRs = crate::op::I32TruncSatF32S_RS;
    type OpSr = crate::op::I32TruncSatF32S_SR;
    type OpSs = crate::op::I32TruncSatF32S_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum I32TruncSatF32U {}
impl crate::UnaryOperator for I32TruncSatF32U {
    const NAME: &'static ::core::primitive::str = "I32TruncSatF32U";
    type OpRr = crate::op::I32TruncSatF32U_RR;
    type OpRs = crate::op::I32TruncSatF32U_RS;
    type OpSr = crate::op::I32TruncSatF32U_SR;
    type OpSs = crate::op::I32TruncSatF32U_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum I32TruncSatF64S {}
impl crate::UnaryOperator for I32TruncSatF64S {
    const NAME: &'static ::core::primitive::str = "I32TruncSatF64S";
    type OpRr = crate::op::I32TruncSatF64S_RR;
    type OpRs = crate::op::I32TruncSatF64S_RS;
    type OpSr = crate::op::I32TruncSatF64S_SR;
    type OpSs = crate::op::I32TruncSatF64S_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum I32TruncSatF64U {}
impl crate::UnaryOperator for I32TruncSatF64U {
    const NAME: &'static ::core::primitive::str = "I32TruncSatF64U";
    type OpRr = crate::op::I32TruncSatF64U_RR;
    type OpRs = crate::op::I32TruncSatF64U_RS;
    type OpSr = crate::op::I32TruncSatF64U_SR;
    type OpSs = crate::op::I32TruncSatF64U_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum I64TruncSatF32S {}
impl crate::UnaryOperator for I64TruncSatF32S {
    const NAME: &'static ::core::primitive::str = "I64TruncSatF32S";
    type OpRr = crate::op::I64TruncSatF32S_RR;
    type OpRs = crate::op::I64TruncSatF32S_RS;
    type OpSr = crate::op::I64TruncSatF32S_SR;
    type OpSs = crate::op::I64TruncSatF32S_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum I64TruncSatF32U {}
impl crate::UnaryOperator for I64TruncSatF32U {
    const NAME: &'static ::core::primitive::str = "I64TruncSatF32U";
    type OpRr = crate::op::I64TruncSatF32U_RR;
    type OpRs = crate::op::I64TruncSatF32U_RS;
    type OpSr = crate::op::I64TruncSatF32U_SR;
    type OpSs = crate::op::I64TruncSatF32U_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum I64TruncSatF64S {}
impl crate::UnaryOperator for I64TruncSatF64S {
    const NAME: &'static ::core::primitive::str = "I64TruncSatF64S";
    type OpRr = crate::op::I64TruncSatF64S_RR;
    type OpRs = crate::op::I64TruncSatF64S_RS;
    type OpSr = crate::op::I64TruncSatF64S_SR;
    type OpSs = crate::op::I64TruncSatF64S_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum I64TruncSatF64U {}
impl crate::UnaryOperator for I64TruncSatF64U {
    const NAME: &'static ::core::primitive::str = "I64TruncSatF64U";
    type OpRr = crate::op::I64TruncSatF64U_RR;
    type OpRs = crate::op::I64TruncSatF64U_RS;
    type OpSr = crate::op::I64TruncSatF64U_SR;
    type OpSs = crate::op::I64TruncSatF64U_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum I32Extend8S {}
impl crate::UnaryOperator for I32Extend8S {
    const NAME: &'static ::core::primitive::str = "I32Extend8S";
    type OpRr = crate::op::I32Extend8S_RR;
    type OpRs = crate::op::I32Extend8S_RS;
    type OpSr = crate::op::I32Extend8S_SR;
    type OpSs = crate::op::I32Extend8S_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum I32Extend16S {}
impl crate::UnaryOperator for I32Extend16S {
    const NAME: &'static ::core::primitive::str = "I32Extend16S";
    type OpRr = crate::op::I32Extend16S_RR;
    type OpRs = crate::op::I32Extend16S_RS;
    type OpSr = crate::op::I32Extend16S_SR;
    type OpSs = crate::op::I32Extend16S_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum I64Extend8S {}
impl crate::UnaryOperator for I64Extend8S {
    const NAME: &'static ::core::primitive::str = "I64Extend8S";
    type OpRr = crate::op::I64Extend8S_RR;
    type OpRs = crate::op::I64Extend8S_RS;
    type OpSr = crate::op::I64Extend8S_SR;
    type OpSs = crate::op::I64Extend8S_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum I64Extend16S {}
impl crate::UnaryOperator for I64Extend16S {
    const NAME: &'static ::core::primitive::str = "I64Extend16S";
    type OpRr = crate::op::I64Extend16S_RR;
    type OpRs = crate::op::I64Extend16S_RS;
    type OpSr = crate::op::I64Extend16S_SR;
    type OpSs = crate::op::I64Extend16S_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum I64Extend32S {}
impl crate::UnaryOperator for I64Extend32S {
    const NAME: &'static ::core::primitive::str = "I64Extend32S";
    type OpRr = crate::op::I64Extend32S_RR;
    type OpRs = crate::op::I64Extend32S_RS;
    type OpSr = crate::op::I64Extend32S_SR;
    type OpSs = crate::op::I64Extend32S_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}
pub enum I32WrapI64 {}
impl crate::UnaryOperator for I32WrapI64 {
    const NAME: &'static ::core::primitive::str = "I32WrapI64";
    type OpRr = crate::op::I32WrapI64_RR;
    type OpRs = crate::op::I32WrapI64_RS;
    type OpSr = crate::op::I32WrapI64_SR;
    type OpSs = crate::op::I32WrapI64_SS;
    fn make_rr(result: crate::Reg, input: crate::Reg) -> Self::OpRr {
        Self::OpRr { result, input }
    }
    fn make_rs(result: crate::Reg, input: crate::Stack) -> Self::OpRs {
        Self::OpRs { result, input }
    }
    fn make_sr(result: crate::Stack, input: crate::Reg) -> Self::OpSr {
        Self::OpSr { result, input }
    }
    fn make_ss(result: crate::Stack, input: crate::Stack) -> Self::OpSs {
        Self::OpSs { result, input }
    }
}

